# 1 перевода строки внутри объекта
module 'Абстрактные модели'
  attr target_object: 'система'

#import everything from types
#import logicals from errors 
#Types#

type Uid : Nat // численный индефикатор пользователя
type Gid : Nat // численный индефикатор группы

type Gids : Gid-set
type Uids : Uid-set


type Permission:
enum
    S_IRUSR // чтение для пользователя
    S_IWUSR // запись для пользователя
    S_IXUSR // исполнение для пользователя
    S_IRGRP // чтение для группы
    S_IWGRP // запись для группы
    S_IXGRP // исполнение для группы
    S_IROTH // чтение для других
    S_IWOTH // запись для других
    S_IXOTH // исполнение для других
endtype


type Permissions : Permission-set


type Cred : struct
{
    Uid cr_uid;            // Real user id
    Uid cr_euid;           // Effective user id
    Uid cr_suid;           // saved effective user id.
    Gid cr_gid;            // Real group id 
    Gid cr_egid;           // effective group id
    Gid cr_sgid;           // Saved effective group id
    Int cr_ngroups;       // number of groups
    Gids cr_groups;     // groups
    Permissions cr_umask;    // umask
}
is
**Cred** - структура, хранящая информацию о правах процесса
endtype



type Fcred : struct
{
    Uid fc_uid;
    Gid fc_gid;
    Permissions fc_permission;
}
is
**Fred** - структура, хранящая информацию о правах доступа файла
endtype


type Sigset : Nat-set
type SignalFlag:
enum
    SA_RESTART // перезапустить системный вызов.
endtype
type SignalFlags : SignalFlag-set


type ProcStatus:
enum
    R // running or runnable (процесс исполняется)
    S // interruptible sleep, waiting for an event to complete (В этом состоянии процесc при блокировке)
is
**ProcStatus** - перечислимый тип, содержащий статус текущего процесса:
$enumdefs$
endtype

type FdFlag: 
enum
    FD_CLOEXEC // close on exec
is
**FdFlag** - перечислимый тип для флагов файловых дескрипторов:
$enumdefs$
endtype

type FileType:
enum
    REGULAR_FILE_TYPE // обычный файл
    DIRECTORY_TYPE    // директория
    SOCKET_TYPE       // сокет
is
**FileType** - перечислимый тип, описывающий типы файлов:
$enumdefs$
endtype

type OpenFileFlag :
enum
    O_RDONLY  // доступ на чтение
    O_WRONLY  // доступ на запись
    O_RDWR    // доступ и на чтение, и на запись
    O_NONBLOCK  // запрет блокировки
is
**OpenFileType** перечислимый тип для флагов открытых файлов:
$enumdefs$
endtype


type OpenFileRefArray : OpenFile-ref-list


type sk_buff : struct #Для *SOCK_DGRAM* и *SOCK_SEQPACKET*, можно сказать, предстваляет получаемую датаграмму. Для *SOCK_STREAM* буфферы будут читаться последовательно, отмечая уже прочитанные данные, учёт которых происходит в *consumed*. При *consumed* == *len* буффер считается полностью прочитанным и удаляется из очереди.
{
    void* buf_data; // буффер в котором передаются данные
    Nat data_len; // количество байт данных
    Nat consumed; // количество прочитанных байт данных (Нужно для SOCK_STREAM).
    void* buf_control_data; // буффер дополнительных данных
    Nat control_len; // количетсво байт дополнительных данных
    Text sender; // адрес отправителя
    OpenFileRefArray of_arr; // ссылки на откртые файлы файловых дескрипторов, которые передаются в сообщении
}
is
**sk_buff** - тип для описания передачи данных в сокетах
endtype



type SocketStatus:
enum
    UNCONNECTED // не подсоединён
    CONNECTING // подключается
    CONNECTED // подключён
    LISTEN // сокет является слушающим
    LISTENING // в данный момент сокет пытается принять сокет на подключение
    CLOSED // закрыт
is
**SocketStatus** - перечеслимый тип, в которых может находится сокет
$enumdefs$
endtype

type SocketFlag: 
enum
       SO_ACCEPTCONN
       SO_ATTACH_FILTER //(since Linux 2.2)
       SO_ATTACH_BPF //(since Linux 3.19)
       SO_ATTACH_REUSEPORT_CBPF
       SO_ATTACH_REUSEPORT_EBPF
       SO_BINDTODEVICE
       SO_BROADCAST
       SO_BSDCOMPAT // Уже не поддерживается
       SO_DEBUG
       SO_DETACH_FILTER //(since Linux 2.2)
       SO_DETACH_BPF //(since Linux 3.19)
       SO_DOMAIN
       SO_ERROR
       SO_DONTROUTE
       SO_INCOMING_CPU //(gettable since Linux 3.19, settable since Linux 4.4)
       SO_KEEPALIVE
       SO_LINGER
       SO_LOCK_FILTER
       SO_MARK //(since Linux 2.6.25)
       SO_OOBINLINE
       SO_PASSCRED
       SO_PASSSEC 
       SO_PEEK_OFF //(since Linux 3.4)
       SO_PEERCRED
       SO_PRIORITY
       SO_PROTOCOL //(since Linux 2.6.32)
       SO_RCVBUF // Does not have effect in unix socket (buf callable?)
       SO_RCVBUFFORCE //(since Linux 2.6.14)
       SO_RCVLOWAT
       SO_SNDLOWAT
       SO_RCVTIMEO
       SO_SNDTIMEO
       SO_REUSEADDR
       SO_REUSEPORT// (since Linux 3.9)
       SO_RXQ_OVFL //(since Linux 2.6.33)
       SO_SNDBUF
       SO_SNDBUFFORCE// (since Linux 2.6.14)
       SO_TIMESTAMP
       SO_TIMESTAMPNS
       SO_TIMESTAMPING
       SO_TYPE
       SO_BUSY_POLL //(since Linux 3.11)
is
**SocketFlag** - перечеслимый тип флагов сокета
end

type SocketFlags : SocketFlag-set

type SockType: # Чтобы закинуть, к примеру SOCK_NONBLOCK и SOCK_STREAM в один set. Пусть будет один тип.
enum
    SOCK_STREAM // потоковый
    SOCK_DGRAM // датаграммный
    SOCK_SEQPACKET // датаграмнный, ориентированный на подключение
    SOCK_RAW // в терминах unix сокетов синоним датаграмнного
   # SOCK_RDM
   # SOCK_PACKET
    SOCK_NONBLOCK // флаг отвечающий за отсутсвие блокировки операций над сокетом 
    SOCK_CLOEXEC // флаг отвечающий за закрытие файлового дескриптора при вызове функции из семейства exec
is
**SockType** - перечеслимый тип для типов и флагов сокетов:
$enumdefs$
endtype

type ShutdownFlags:
enum
    RCV_SHUTDOWN   // сокет не может читать 
    SEND_SHUTDOWN  // сокет не может писать
endtype

type AddressFamily:
enum
    AF_UNIX // то же самое, что и AF_LOCAL
is 
**AddressFamily** - перечеслимый тип семейств адрессов. В данной модели рассматривается только *AF_UNIX*
$enumdefs$
endtype

type sa_family_t = AddressFamily
type sockaddr = sockaddr_un # модель для unix сокетов
type socklen_t = Nat
type ssize_t = Nat
type size_t = Nat


type Protocol:
enum
    PF_UNIX // протокол unix сокетов
    PF_UNSPEC // протокол поумолчанию
is
**Protocol** - протоколы:
$enumdefs$
endtype

type Error: 
enum
    ENOTCONN
    ECONNABORTED
    EACCES
    EAFNOSUPPORT
    EINVAL
    EMFILE
    ENFILE
    ENOBUFS
    ENOMEM
    EPROTONOSUPPORT
    EBADF
    ENOTSOCK
    EINVAL
    EROFS
    EFAULT
    ENAMETOOLONG
    ENOENT
    ENOMEM
    ENOTDIR
    EACCES
    ELOOP
    ESOCKTNOSUPPORT
    EADDRINUSE
    EADDRNOTAVAIL
    EOPNOTSUPP
    EINTR
    EIO
    ENOSPC
    EDQUOT
    EPERM
    EAGAIN
    EALREADY
    ECONNREFUSED
    EINPROGRESS
    EISCONN
    ENETUNREACH
    EPROTOTYPE
    ETIMEDOUT
    EAGAIN
    ECONNABORTED
    EPROTO
    ECONNRESET
    EPIPE
    ESRCH
    EDESTADDRREQ
    EMSGSIZE
is
**Error** - перечеслимый тип ошибок, которые могут возникать в событиях
endtype

type sockaddr_un : struct
{
    AddressFamily sun_family;
    Char* sun_path;
}
is
**sockaddr_un** - структура, представляющая собой адрес unix сокет, которая передаётся, например, в *bind*
endtype

type ShutdownParam:
enum
    SHUT_RD // закрыть чтение
    SHUT_WR // закрыть запись
    SHUT_RDWR // закрыть чтение и запись
is
**ShutdownParam** - перечисление возможных значений параметра *how* в системном вызове *shutdown*
$enumdef$
endtype

type Level:
enum
    SOL_SOCKET // глобальные опции сокетов или опции unix сокетов
endtype

type MsgFlag:
enum
    MSG_CMSG_CLOEXEC # recvmsg only
    MSG_CONFIRM # implemented only ip => unix socket does not support this flag
    MSG_DONTROUTE # Похоже значение просто игнорируется
    MSG_DONTWAIT # OK
    MSG_EOR # Документация врёт. Он не возвращается в recv
    MSG_TRUNC # ok
    MSG_CTRUNC # OK
    MSG_PEEK
    MSG_MORE # Unix socket does not support this flag 
    MSG_NOSIGNAL # Don't generate a SIGPIPE signal if the peer on a stream-oriented socket  has closed the connection.  The EPIPE error is still returned.  This provides similar behavior to using sigaction(2) to ignore SIGPIPE, but, whereas MSG_NOSIGNAL is a per-call feature, ignoring SIGPIPE sets  a  process  attribute  that  affects  all threads in the process
    #/* On Linux, we must transmit at least 1 byte of real data in order to send ancillary data */
    MSG_OOB # Unix socket does not support this flag -> EINVAL как я понимаю
    
is
**MsgFlgas** - перечислимый тип флагов для функций вводы/вывода сокетов
endtype

type CmsgType:
enum
    SCM_RIGHTS 
    SCM_CREDENTIALS  
    SCM_SECURITY
is
**CmsgType** - перечислимый тип дополнительных данных в msghdr
end

type cmsghdr : struct {
    Nat cmsg_len;
    Level cmsg_level;
    CmsgType cmsg_type;
    Char* cmsg_data;
}
is
**cmsghdr** - структура данных, для дополнительных данных в msghdr
end

const MAX_ANCILLARY_BUFFER : Nat // значение в /proc/sys/net/core/optmem_max

type MsgFlags : MsgFlag-set

type iovec : struct {
    void* iov_base;
    Nat iov_len;
}
is
**iovec** - iovec для msghndr
endtype


type msghdr : struct {
    Char*     msg_name;
    Nat       msg_namelen;
    iovec*    msg_iov;
    Nat       msg_iovlen;
    void*     msg_control;
    Nat       msg_controllen;
    MsgFlags  msg_flags;
}
is
**msghdr** - структура для sendmsg/recvmsg
endtype



type RequstedAccessType:
enum
    READ
    WRITE
    EXEC
endtype

#TypesEnd

object OS is 
**OS** - объект, представляющий систему целиком
end

objattr os_open_file_table : OpenFile-set is
**os_open_file_table** - таблица открытых файлов ОС. В этой таблице происходит регистрация всех открытых в системе файлов
end

objattr os_files : File-list is
**os_files** - список всех файлов в файловой системе
end

objattr os_proceses : Process-set is 
**os_proceses** - множество процессов в системе
end

objattr os_socket_table : Text -m-> Socket is
**os_socket_table** - таблица сокетов (отображение адресса unix сокета (т.е. строки) в объект сокет с таким адресом)
end

objattr os_users : Uid-set is
**os_users** - множество всех пользователей, зарегистрированных в системе (/etc/passwd)
end

objattr os_groups : Gid-set is
**os_groups** - множество всех групп, зарегистрированных в системе (/etc/group)
end
endobject



object Process is
**Process** - объект, представляющий отдельный процесс ОС
end

objattr proc_pid : Int is
**proc_pid** - уникальный идентификатор процесса
end

objattr proc_errno : Int is
**proc_errno** - атрибут, хранящий целочисленный код последней ошибки
end

objattr proc_fds : Nat -m-> Fd is 
**proc_fds** - таблица открытых файловых дескрипторов процесса
end

objattr proc_cred : Cred is
**proc_cred** - информация о правах процесса
end

objattr proc_pending_signals : Nat-list is
**proc_pending_signals** - список номеров сигналов, пришедших на обработку
end

objattr proc_signal_flags : Nat -m-> SignalFlags is
**proc_signal_flags** - отображение номера сигнала в множество флагов этого сигнала
end

objattr proc_blocked_signals : Sigset is
**proc_blocked_signals** - множество заблокированных для обработки сигналов (если номер сигнала есть, то этот сигнал не обрабатывается)
end

objattr proc_status : ProcStatus is 
**proc_status** - текущее состояние процесса
end

objattr proc_cur_path : Text is
**proc_cur_path** - текущая рабочая директория процесса
end
endobject



object Fd is
**Fd** - объект, представляющий собой файловый дескриптор
end

objattr fd_open_file_ref : OpenFile* is 
**fd_open_file_ref** - ссылка на структуру с информацией об открытом файле
end

objattr fd_flags : FdFlag-set is # Хотя возможен только один
**fd_flags** - флаги, которые приписаны к файловому дескриптору на уровне конкретного процесса
end
endobject

object File is
**File** - объект, представляющий файл в ФС
end

objattr file_path : Text is
**file_path** - абсолютный путь файла
end

objattr file_type : FileType is
**file_type** - тип файла
end

objattr file_cred : Fcred is
**file_cred** - информация об обладателе и правах доступа
end
endobject



object OpenFile is 
**OpenFile** - объект, представляющий открытый файл в ОС
end

# Бывший of_op_type - операции определённые для этого типа. Этим хотелось выразить наличия поля op в стркутуре откртытого файла, с целью различения типов открытых файлов. Здесь он просто равен типу файлу.
objattr of_type : FileType is
**of_type** - тип открытого файла (дублирует тип файла)
end

objattr of_file : File* is
**of_file** - хранит ссылку на соотвестующий этому **OpenFile**, объект **File**
end

objattr of_ref_cnt : Int is
**of_ref_cnt** - число ссылающихся на этот открытый файл файловых дескрипторов
end

objattr of_flags : OpenFileFlag-set is
**of_flags** - флаги открытого файла
end

objattr of_private_data : Socket* is
**of_private_data** - ссылка на важные структура данных для различных типов открытого файла (ссылка на структуру сокет для сокета)
end
endobject



object Socket is 
**Socket** - объект, представляющий собой UNIX сокет.
end

objattr socket_status : SocketStatus is
**socket_status** - текущий статус сокета
end

objattr socket_name : Text is
**socket_name** - значение в поле структуры sockaddr_un
end

objattr socket_address : Text is
**socket_address** - адрес сокета
end

objattr socket_addrlen : Nat is
**socket_addrlen** - длина адреса сокета
end

objattr socket_queue : Socket-list is 
**socket_queue** - очередь поступивщих на подключение сокетов
end

#полностью настроенных сокетов, которые ждут принятия.
objattr socket_backlog : Int is
**socket_backlog** - максимально возможная длина очереди **socket_queue**
end

objattr socket_peer : Socket-ref is
**socket_peer** - ссылка на объект сокета, с котором происходит общение
end

objattr socket_flags : SocketFlags is
**socket_flags** - флаги сокета
end

objattr socket_type : SockType is
**socket_type** - тип сокета (без SOCK_NONBLOCK и SOCK_CLOEXEC. Эти флаги перешли в флаги открытого файла и файлового дескриптора этого сокета соотвественно)
end

objattr socket_shutdown_flags : ShutdownFlags-set is
**socket_shutdown_flags** - флаги, обозначающие закрытие на операции чтения и записи, выполняемые этим сокетом
end

objattr socket_buf : sk_buff-list is
**socket_buf_list** - список полученных буфферов сокета
end

objattr socket_so_sndbuf : Nat is
**socket_so_buff** - размер буффера сокета (значение, получаемое с помощью getsockopt() с параметром SO_SNDBUF)
end

objattr socket_used_buffer : Nat is
**socket_used_buffer** - использованный объём буффера (в байтах) 
end

objattr socket_cur_buffer_cnt : Nat is
**socket_cur_buffer_cnt** - количество выделенных буфферов
end
endobject


const DEFAULT_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_default
const MAX_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_max


logical to_sockaddr_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : sockaddr_un*
function
    * Преобразует указатель в sockaddr_un
end
    attr text: '((sockaddr_un*) {prm1})'


logical to_nat_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Nat*
function
    * Преобразует указатель в Nat*
end
    attr text: '((unsigned*) {prm1})'


logical to_int_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Int*
function
    * Преобразует указатель в Int*
end
    attr text: '((int*) {prm1})'

logical to_char_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Char*
function
    * Преобразует указатель в char*
end
    attr text: '((char*) {prm1})'


logical to_void_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : void*
function
    * Преобразует указатель в void*
end
    attr text: '((void*) {prm1})'



logical to_ucred_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Ucred*
function
    * Преобразует указатель в Ucred*
end
    attr text: '((Ucred*) {prm1})'

logical to_cmsghdr_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : cmsghdr*
function
    * преобразует указатель в указатель на cmsghdr
end
    attr text: '((cmsghdr*) {prm1})'
    
 
logical to_text
params
    char_arr @IN  : Char*
    arr_len  @IN  : Nat
    ret      @OUT : Text
function
    * Вернуть абстрактный тип Text из массива символов
end
    attr text: '{char_arr}'
    
    
logical to_char_arr
params
    text1    @IN  : Text
    char_arr @OUT : Char*
function
    * Вернуть массив символов из абстрактного типа Text 
end
    attr text: '{text1}'


logical generate_fd
params
    current @IN  : Process
    fd      @OUT : Nat
function
    forany(newFD : Nat | newFD \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD) => nn \isin \dom(current.proc_fds)) {
        return newFD
    }
end
    attr text: 'свободный файловый дескриптор текущего процесса с номером таким, что все файловые дескрипторы с меньшим номером уже используются'


action add_to_list
params
    T @TYPE
    l @IN : T-list
    el   @IN : T
function 
    l(\len l) := el // !Добавить el в конец списка l
end


action del_from_list
params
    T @TYPE
    l @IN  : T-list
function
    * Удалить первый элемент из списка l.
end



action add_to_set
params
  T     @TYPE
  set1  @IN    : T-set
  el    @IN    : T
function
  set1 := set1 ∪ {. el .} // !Добавить el в set1
end



action remove_from_set
params
  T    @TYPE
  set1 @IN   : T-set
  el   @IN   : T
function
  set1 := set1 \diff {. el .} // !Убрать el из set1 
end 



logical get_sock_data // получить структуру данных для процесса current и сокета sockfd.
params
    current @IN  : Process
    sockfd  @IN  : Nat
    sock    @OUT : Socket
function
    return \deref(current.proc_fds(sockfd).fd_open_file_ref->of_private_data)
end
    attr text: 'сокет, соответствующий файловому дескриптору {sockfd}'

# end of несмотрел

logical get_by_address
params
    os        @IN  : OS
    sock_addr @IN  : Text
    sock      @OUT : Socket
function 
    return os.os_socket_table(sock_addr)
end
    attr text: 'сокет, соотвествующий адресу {sock_addr}'



# Для сокращения записи
logical get_open_file // получить открытый файл для процесс current и сокета fd.
params
    current @IN  : Process
    fd      @IN  : Nat
    opefile @OUT : OpenFile
function
    return \deref(current.proc_fds(fd).fd_open_file_ref)
end    
    attr text: 'открытый файл, соответствующий файловому дескриптору {fd}'


action add_to_map
params
  T1    @TYPE
  T2    @TYPE
  map   @IN    : T1 -m-> T2
  key   @IN    : T1
  el    @IN    : T2
function
    map(key) := el // !Добавить el в map с ключом key
end



action remove_from_map
params
  T1  @TYPE
  T2  @TYPE
  map @IN : T1 -m-> T2
  key @IN : T1
function
    * Удалить элемент key из map
end


const NULL : void*
const Nothing // Константа для неинициализированных частей



function socket is
/**
 * @param domain    IN домен
 * @param sock_type IN тип и флаги сокета, соединеные через битовое OR
 * @param protocol  IN протокол домена 
 * @return файловый дескриптор в случае успешного выполнения, иначе -1.
 */
int socket(int domain, int sock_type, int protocol);
end


event socket // вызов функции socket
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fd        @OUT : Int
invariant domain == AF_UNIX # Модель только для UNIX сокетов
function
    possible_errors = socket_errors(os, current, domain, sock_type, protocol)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    newFD = generate_fd(current)
    newSocket = 'mk_socket(.socket_status=UNCONNECTED, .socket_address=Nothing, .socket_addrlen=Nothing, .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(), socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)' // новый сокет с атрибутами: .socket_status=UNCONNECTED, .socket_address=Nothing, .socket_addrlen=Nothing, .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(), socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0
        
    if (SOCK_STREAM \isin sock_type) {
        newSocket.socket_type := SOCK_STREAM
    } elif (SOCK_SEQPACKET \isin sock_type) {
       newSocket.socket_type := SOCK_SEQPACKET
    } else {
       newSocket.socket_type := SOCK_DGRAM
    }
    
        
    if (SOCK_NONBLOCK \isin sock_type) {
        openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR, O_NONBLOCK .}, .of_private_data=newSocket)' 
    } else {
        openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=newSocket)' 
    }
    
    if (SOCK_CLOEXEC \isin sock_type) {
        newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. FD_CLOEXEC .})'
    } else {
        newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'
    }
    
    add_to_map(current.proc_fds, newFD, newFDObject)
    add_to_set(os.os_open_file_table, openfile)
        
    return newFD
end
    attr summary-cfg: True
    attr algo-tree: True



const PATH_MAX : Nat // Maximum path size in system



logical get_abs_path
params
    current  @IN  : Process
    path     @IN  : Char*
    path_len @IN  : Nat
    abs      @OUT : Text
function
    if (path[0] == "\0") {
        return to_text(path, path_len)
    }
    
    * Если путь абсолютный, то избавляемся от ., .., символьных ссылок в пути. 
    * Если путь относительный, добавляем слева current.proc_cur_path и избавляемся от ., .. и символьных ссылок в пути 
    # man path_resolution
    * Вернуть полученный адрес
end
    attr text: 'абсолютный путь файла {path}'



const AutoBindAlphabet : Char-set // character set [0-9a-f]

function bind is
/**
 * @param sockfd  IN файловый дескриптор сокета
 * @param addr    IN адрес для связывания с сокетом
 * @param addrlen IN длина адреса
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int bind(int sockfd, sockaddr *addr, socklen_t addrlen);
end

event bind // вызов функции bind
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    addr     @IN  : sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Int
function    
    possible_errors = bind_errors(os, current, sockfd, addr, addrlen)    
    
    sock_address = get_abs_path(current, addr->sun_path, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }
    
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)

    socket.socket_address := sock_address
    
    if (addrlen == sizeof('sa_family_t')) { # Autobind feature -- Linux feature
        // Autobind feature
        forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && \len(newUnixAddress) == 6 && newUnixAddress(0) == '\0' && newUnixAddress(1) \isin AutoBindAlphabet && newUnixAddress(2) \isin AutoBindAlphabet && newUnixAddress(3) \isin AutoBindAlphabet && newUnixAddress(4) \isin AutoBindAlphabet && newUnixAddress(5) \isin AutoBindAlphabet) {
            socket.socket_address := sock_address
            socket.socket_addrlen := 6 # One byte \0 + 5 of autobind address The change to 5 bytes came in Linux 2.3.15.)
            add_to_map(os.os_socket_table, sock_address, socket) # зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
            
            return 0
        }
    } else {
        if (sock_address(0) != '\0') { # Обычный сокет. Абстрактному сокету это не нужно.
            newFile = 'mk_File(.file_path=sock_address, .file_type=SOCKET_TYPE, .file_cred = { fc_uid, .fc_gid, .fc_permissions = {. S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH.} \diff current.proc_cred.cr_umask })' // Создание нового файла
            add_to_list(os.os_files, newFile)
            openfile.of_file := newFile // сокет связывается с созданным файлом
        }
        
        socket.socket_name := to_text(addr->sun_path, addrlen - sizeof('sa_family_t'))
        socket.socket_addrlen := addrlen
        add_to_map(os.os_socket_table, sock_address, socket) // зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
        
        return 0
    }
end
    attr summary-cfg: True
    attr algo-tree: True



const SOMAXCONN : Nat // максимально возможный размер очереди запросов на подключение (значение в /proc/sys/net/core/somaxconn файле)


function listen is
/**
 * @param sockfd  IN файловый дескриптор.
 * @param backlog IN числовой параметр, определяющий максиманльную длину очереди запросов на подключение.
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int listen(int sockfd, int backlog);
end



event listen // вызов функции listen
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Int
function
    possible_errors = listen_errors(os, current, sockfd, backlog)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (backlog > SOMAXCONN) {
        socket.socket_backlog := SOMAXCONN
    } else {
        socket.socket_backlog := backlog
    }
    
    socket.socket_status := LISTEN
        
    return 0
end
    attr summary-cfg: True
    attr algo-tree: True


logical is_free_space_in_backlog
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появилось место для постановки себя в очередь на подключение (\len(server.socket_queue) < server.socket_backlog)



logical was_accepted
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    socket     @IN  : Socket
    res        @OUT : Bool 
end
    attr event-desc: Запрос на подключение был принят сервером. (socket \notisin server.socket_queue).


function connect is
/**
 * @param sockfd  IN файловый дескриптор сокета
 * @param addr    IN адрес сокета, которому нужно подключиться
 * @param addrlen IN длина адреса сокета, к которому нужно подключиться 
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int connect(int sockfd, sockaddr *addr, socklen_t addrlen);
end


event connect // вызов функции connect
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    addr     @IN  : sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Int 
function    
    socket = get_sock_data(current, sockfd)
    abs_path = get_abs_path(current, addr->sun_path, addrlen)
    server = get_by_address(os, abs_path) //! server — сокет, к которому нужно подключиться

    possible_errors = connect_errors(os, current, sockfd, addr, addrlen, server)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    if (socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) {
        socket.socket_status := CONNECTING
        current.proc_status := S //! Установить атрибуту proc_status текущего процесса значение S.
        
        wait INFWAIT { // состояние ожидания появления места для постановки в очередь на подключение
            trigger (is_free_space_in_backlog(server)) { // появления места для постановки в очередь на подключение
                current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
                add_to_list(server.socket_queue, socket) 
            }
            
            trigger (interrupt_logical(current, socket)) { // произошло прерывание во время блокировки системного вызова
                current.proc_errno := EINTR //! Установить атрибуту proc_errno текущего процесса значение EINTR.
                current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
                return -1
            }
        }
        
        current.proc_status := S //! Установить атрибуту proc_status текущего процесса значение S.
        
        wait INFWAIT { // состояние ожидания принятия запроса на подключение сервером
            trigger (was_accepted(server, socket)) { // принятия запроса на подключение сервером
                #socket.socket_status := CONNECTED -- устанавливает это сервер (в accept)
                #socket.socket_peer := -- устанавливает это сервер.
                #del_from_list(server.socket_queue, 0) -- делает сервер
                current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            }
                
            trigger (interrupt_logical(current, socket)) { // произошло прерывание во время блокировки системного вызова
                current.proc_errno := EINTR //! Установить атрибуту proc_errno текущего процесса значение EINTR.
                current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
                return -1
            }
        }
    } else {
        socket.socket_peer := \ref(server)
        socket.socket_status := CONNECTED
    }
    
    return 0    
end
    attr summary-cfg: True
    attr algo-tree: True



logical backlog_is_not_empty
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появился запрос на подключение (server.socket_queue != <..>)


function accept4 is
/**
 * @param sockfd  IN файловый дескриптор сокета
 * @param addr    IN адрес принятного сокета
 * @param addrlen IN длина принятного сокета 
 * @param flags   IN флаги SOCK_NONBLOCK, SOCK_CLOEXEC, соединеные через битовое OR
 * @return файловый дескриптор в случае успешного выполнения, иначе -1.
 */
int accept4(int sockfd,sockaddr *addr, socklen_t *addrlen, int flags);
end


event accept4 // вызов функции accept4
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat*
    flags    @IN  : SockType-set
    ret      @OUT : Int
function
    possible_errors = accept4_errors(os, current, sockfd, sockaddr, addrlen, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    socket.socket_status := LISTENING
    current.proc_status := S //! Установить атрибуту proc_status текущего процесса значение S.
    
    wait INFWAIT { // состояние ожидания после вызова функции accept4
        trigger (backlog_is_not_empty(socket)) { // появления запроса на подключение
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            socket.socket_status := LISTEN
            peer = socket.socket_queue(0) // Тот, кто подсоединяется
            del_from_list(socket.socket_queue)
            newFD = generate_fd(current) # Создаются fd, OpenFile, Socket. Причём все поля у новых OpenFile и Socket такие же, как и у этих же объектов соотвестующих sockfd. 
            forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && newUnixAddress(0) == '\0') {
                new_socket = 'mk_socket(.socket_status=CONNECTED, .socket_name=newUnixAddress, .socket_address=newUnixAddress, .socket_addrlen=\len(newUnixAddress), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=peer, .socket_flags={. .}, .socket_type=socket.socket_type, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=socket.socket_so_sndbuf, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
            
            
                peer.socket_peer := new_socket
                peer.socket_status := CONNECTED
                
                if (sockaddr != to_sockaddr_pointer(NULL)) { //sockaddr != NULL
                    memcpy(to_void_pointer(sockaddr->sun_path),  to_void_pointer(to_char_arr(newUnixAddress)), \len(newUnixAddress))
                    \deref(addrlen) := \len(newUnixAddress)      
                }

                openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, of_flags={. O_RDWR .}, .of_private_data=socket)'    
                newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'
                
                if (SOCK_NONBLOCK \isin flags) {
                    add_to_set(openfile.of_flags, O_NONBLOCK)
                }
                
                if (SOCK_CLOEXEC \isin flags) {
                    add_to_set(newFDObject.fd_flags, FD_CLOEXEC)
                }

                add_to_map(current.proc_fds, newFD, newFDObject)
                add_to_set(os.os_open_file_table, openfile)
                add_to_map(os.os_socket_table, new_socket.socket_address, new_socket)
            
                return newFD   
            }
        }
            
        trigger (interrupt_logical(current, socket)) { // произошло прерывание во время блокировки системного вызова
            current.proc_errno := EINTR //! Установить атрибуту proc_errno текущего процесса значение EINTR.
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            socket.socket_status := LISTEN
            
            return -1   
        }
    }
end


function accept is
/**
 * @param sockfd  IN файловый дескриптор сокета
 * @param addr    IN адрес принятного сокета
 * @param addrlen IN длина принятного сокета 
 * @return файловый дескриптор в случае успешного выполнения, иначе -1.
 */
int accept(int sockfd, sockaddr *addr, socklen_t *addrlen);
end


event accept // вызов функции accept
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat*
    ret      @OUT : Int
function
    possible_errors = accept_errors(os, current, sockfd, sockaddr, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    socket.socket_status := LISTENING
    current.proc_status := S //! Установить атрибуту proc_status текущего процесса значение S.
    
    wait INFWAIT { // состояние ожидания после вызова функции accept
        trigger (backlog_is_not_empty(socket)) { // появления запроса на подключение
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            socket.socket_status := LISTEN
            peer = socket.socket_queue(0) // Тот, кто подсоединяется
            del_from_list(socket.socket_queue)
            newFD = generate_fd(current) // Создаются fd, OpenFile, Socket. Причём все поля у новых OpenFile и Socket такие же, как и у этих же объектов соотвестующих sockfd. 
                forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && newUnixAddress(0) == '\0') {
                    new_socket = 'mk_socket(.socket_status=CONNECTED, .socket_name=newUnixAddress, .socket_address=newUnixAddress, .socket_addrlen=\len(newUnixAddress), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=peer, .socket_flags={. .}, .socket_type=socket.socket_type, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=socket.socket_so_sndbuf, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                
                    peer.socket_peer := new_socket
                    peer.socket_status := CONNECTED
                    
                    if (sockaddr != to_sockaddr_pointer(NULL)) { //sockaddr != NULL
                        memcpy(to_void_pointer(sockaddr->sun_path),  to_void_pointer(to_char_arr(newUnixAddress)), \len(newUnixAddress))
                        \deref(addrlen) := \len(newUnixAddress)      
                    }

                    openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, of_flags={. O_RDWR .}, .of_private_data=socket)'    
                    newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'

                    add_to_map(current.proc_fds, newFD, newFDObject)
                    add_to_set(os.os_open_file_table, openfile)
                    add_to_map(os.os_socket_table, new_socket.socket_address, new_socket)
                
                    return newFD   
                }
             
        }
            
        trigger (interrupt_logical(current, socket)) { // произошло прерывание во время блокировки системного вызова
            current.proc_errno := EINTR //! Установить атрибуту proc_errno текущего процесса значение EINTR.
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            socket.socket_status := LISTEN
            
            return -1   
        }
    }
end
    attr summary-cfg: True
    attr algo-tree: True

function close is
/**
 * @param fd IN файловый дескриптор
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int close(int fd);
end


event close // вызов функции close
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Int
invariant current.proc_fds(fd).fd_open_file_ref.of_ref_cnt >= 1// Если у файла ref_cnt == 0, то его в этой таблице быть не должно 
invariant current.proc_fds(fd).fd_open_file_ref.of_type == SOCKET_TYPE// Вызов рассматривается только для сокетов
function
    possible_errors = close_errors(os, current, fd)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, fd)
    open_file = get_open_file(current, fd)

    remove_from_map(current.proc_fds, fd)
    open_file.of_ref_cnt--
 
    if (open_file.of_ref_cnt == 0) {
        socket.socket_peer.socket_status := CLOSED
        remove_from_set(os.os_open_file_table, open_file)
        remove_from_map(os.os_socket_table, socket.socket_address)
    }
    
    return 0
end
    attr summary-cfg: True
    attr algo-tree: True


function shutdown is
/**
 * @param sockfd IN файловый дескриптор сокета
 * @param how    IN флаг закрытия ввода, вывода, ввода и вывода
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int shutdown(int sockfd, int how);
end



event shutdown // вызов функции shutdown
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Int
function
    possible_errors = shutdown_errors(os, current, sockfd, how)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    peer = socket.socket_peer

    if (how == SHUT_RD) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)  
    } elif (how == SHUT_WR) {
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    } elif (how == SHUT_RDWR) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    }
    
    return 0    
end
    attr summary-cfg: True
    attr algo-tree: True


function socketpair is
/**
 * @param domain    IN домен
 * @param sock_type IN тип и флаги сокетов, соединеные через битовое OR
 * @param protocol  IN протокол домена 
 * @param sv        IN файловые дескрипторы сокетов 
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int socketpair(int domain, int sock_type, int protocol, int sv[2]);
end


event socketpair // вызов функции socketpair
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    sv        @IN  : Int*
    ret       @OUT : Int
function
    possible_errors = socketpair_errors(os, current, domain, sock_type, protocol, sv)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }
    
    forany(newUnixAddress1 : Text | newUnixAddress1 \notisin \dom(os.os_socket_table) && newUnixAddress1(0) == '\0') {
        forany(newUnixAddress2 : Text | newUnixAddress2 \notisin \dom(os.os_socket_table) && newUnixAddress2(0) == '\0') {
            if (SOCK_CLOEXEC \isin sock_type) {
                newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. FD_CLOEXEC .})'
                newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. FD_CLOEXEC .})'
            } else {
                newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. .})'
                newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. .})'
            }
            
            newFD1 = generate_fd(current)
            add_to_map(current.proc_fds, newFD1, newFDObject1)
            newFD2 = generate_fd(current)
            add_to_map(current.proc_fds, newFD2, newFDObject2)
        
            socket1 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress1, .socket_addrlen=\len(newUnixAddress1), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
            socket2 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress2, .socket_addrlen=\len(newUnixAddress2), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
            socket1.socket_peer := socket2
            socket2.socket_peer := socket1
            
            
            
            if (SOCK_STREAM \isin sock_type) {
                socket1.socket_type := SOCK_STREAM
                socket2.socket_type := SOCK_STREAM
            } elif (SOCK_SEQPACKET \isin sock_type) { 
                socket1.socket_type := SOCK_SEQPACKET
                socket2.socket_type := SOCK_SEQPACKET
            } else { # SOCK_DGRAM, SOCK_RAW
                socket1.socket_type := SOCK_DGRAM
                socket2.socket_type := SOCK_DGRAM
            } 
            
            openfile1 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket1)'
            openfile2 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket2)'    
                
            if (SOCK_NONBLOCK \isin sock_type) {
                add_to_set(openfile1.of_flags, O_NONBLOCK)
                add_to_set(openfile2.of_flags, O_NONBLOCK)
            }
            
            add_to_set(os.os_open_file_table, openfile1)
            add_to_set(os.os_open_file_table, openfile2)
            add_to_map(os.os_socket_table, newUnixAddress1, socket1)
            add_to_map(os.os_socket_table, newUnixAddress2, socket2)

            sv[0] := newFD1
            sv[1] := newFD2
            
            return 0
        }
    }
end
    attr summary-cfg: True
    attr algo-tree: True

############## IO part start ###########

#TODO
#event getsockopt
#params
#    os      @IN  : OS
#    current @IN  : Process
#    sockfd  @IN  : Nat
#    level   @IN  : Level
#    optname @IN  : SocketFlag
#    optval  @IN  : void*
#    optlen  @IN  : Nat*
#    ret     @OUT : Int
#function
#    if (optname == SO_ACCEPTCONN) {
#    } elif (optname == SO_ATTACH_FILTER) {
#    } elif (optname == SO_ATTACH_BPF) {
#    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
#    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
#    } elif (optname == SO_BINDTODEVICE) {
#    } elif (optname == SO_BROADCAST) {
#    } elif (optname == SO_BSDCOMPAT) {
#    } elif (optname == SO_DEBUG) {
#    } elif (optname == SO_DETACH_FILTER) {
#    } elif (optname == SO_DETACH_BPF) {
#    } elif (optname == SO_DOMAIN) {
#    } elif (optname == SO_ERROR) {
#    } elif (optname == SO_DONTROUTE) {
#    } elif (optname == SO_INCOMING_CPU) {
#    } elif (optname == SO_KEEPALIVE) {
#    } elif (optname == SO_LINGER) {
#    } elif (optname == SO_LOCK_FILTER) {
#    } elif (optname == SO_MARK) {
#    } elif (optname == SO_OOBINLINE) {
#    } elif (optname == SO_PASSCRED) {
#    } elif (optname == SO_PASSSEC) {
#    } elif (optname == SO_PEEK_OFF) {
#    } elif (optname == SO_PEERCRED) {
#    } elif (optname == SO_PRIORITY) {
#    } elif (optname == SO_PROTOCOL) {
#    } elif (optname == SO_RCVBUF) {
#    } elif (optname == SO_RCVBUFFORCE) {
#    } elif (optname == SO_RCVLOWAT) {
#    } elif (optname == SO_SNDLOWAT) {
#    } elif (optname == SO_RCVTIMEO) {
#    } elif (optname == SO_SNDTIMEO) {
#    } elif (optname == SO_REUSEADDR) {
#    } elif (optname == SO_REUSEPORT) {
#    } elif (optname == SO_RXQ_OVFL) {
#    } elif (optname == SO_SNDBUF) {
#    } elif (optname == SO_SNDBUFFORCE) {
#    } elif (optname == SO_TIMESTAMP) {
#    } elif (optname == SO_TIMESTAMPNS) {
#    } elif (optname == SO_TYPE) {
#    } elif (optname == SO_BUSY_POLL) {
#    } elif (optname == SO_TIMESTAMPING) {
#    }
#    
#    return 0
#end


#event setsockopt
#params
#    os      @IN  : OS
#    current @IN  : Process
#    sockfd  @IN  : Nat
#    level   @IN  : Level
#    optname @IN  : SocketFlag
#    optval  @IN  : void*
#    optlen  @IN  : Nat
#    ret     @OUT : Int
#function
#    #if (optname == SO_ACCEPTCONN) - не settable
#    if (optname == SO_ATTACH_FILTER) {
#    } elif (optname == SO_ATTACH_BPF) {
#    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
#    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
#    } elif (optname == SO_BINDTODEVICE) {
#    } elif (optname == SO_BROADCAST) {
#    } elif (optname == SO_BSDCOMPAT) {
#    } elif (optname == SO_DEBUG) {
#    } elif (optname == SO_DETACH_FILTER) {
#    } elif (optname == SO_DETACH_BPF) {
#    } elif (optname == SO_DOMAIN) {
#    } elif (optname == SO_ERROR) {
#    } elif (optname == SO_DONTROUTE) {
#    } elif (optname == SO_INCOMING_CPU) {
#    } elif (optname == SO_KEEPALIVE) {
#    } elif (optname == SO_LINGER) {
#    } elif (optname == SO_LOCK_FILTER) {
#    } elif (optname == SO_MARK) {
#    } elif (optname == SO_OOBINLINE) {
#    } elif (optname == SO_PASSCRED) {
#    } elif (optname == SO_PASSSEC) {
#    } elif (optname == SO_PEEK_OFF) {
#    } elif (optname == SO_PEERCRED) {
#    } elif (optname == SO_PRIORITY) {
#    } elif (optname == SO_PROTOCOL) {
#    } elif (optname == SO_RCVBUF) {
#    } elif (optname == SO_RCVBUFFORCE) {
#    } elif (optname == SO_RCVLOWAT) {
#    } elif (optname == SO_SNDLOWAT) {
#    } elif (optname == SO_RCVTIMEO) {
#    } elif (optname == SO_SNDTIMEO) {
#    } elif (optname == SO_REUSEADDR) {
#    } elif (optname == SO_REUSEPORT) {
#    } elif (optname == SO_RXQ_OVFL) {
#    } elif (optname == SO_SNDBUF) {
#    } elif (optname == SO_SNDBUFFORCE) {
#    } elif (optname == SO_TIMESTAMP) {
#    } elif (optname == SO_TIMESTAMPNS) {
#    } elif (optname == SO_TYPE) {
#    } elif (optname == SO_BUSY_POLL) {
#    } elif (optname == SO_TIMESTAMPING) {
#    }
#    
#    return 0
#end



logical interrupt_logical
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    current    @IN  : Process 
    socket     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Прерывание ожидания процесса, из-за прихода сигнала, который не блокируется маской (current.proc_pending_signals != <..> && exists x:Nat | (x \isin current.proc_pending_signals) && (x \notisin curren.proc_blocked_signals)). Если для пришедшего сигнала верно SA_RESTART \isin current.proc_signal_flags(signum) && SO_RCVTIMEO \notisin socket.socket_flags это эквиваленто перезапуску системного вызова т.е. в этом случае res == False, иначе res == True. 



logical max_msg_cnt # Я не знаю как это получить. Оно зависит от SO_SNDBUF текущего сокета => Параметр - сокет-отправитель
params
    sock @IN  : Socket
    ret  @OUT : Nat
function
    * максимальное число отправленных сообщений в очереди
    # Как-то связано с so_sndbuf. Как это посчитать не знаю
end



logical get_msg_len
params
    msg @IN  : msghdr*
    res @OUT : Nat
function
    def _res : Nat := 0

    for (i in [0..msg.msg_iovlen]) {
        _res := _res + msg.msg_iov[i].iov_len
    }
    
    return _res
end
    attr text: 'длина сообщения в {msg}'


event load_data
params
    current @IN  : Process // текущий процесс
    msg     @IN  : msghdr*
    sender  @IN  : Socket
    reciver @IN  : Socket
    ret     @OUT : Nat
function
    def buf : sk_buff := 'mk_skbuff(".buf_data = alloc_ptr(), .data_len = 0, .consumed = 0, buf_control_data = alloc_prt(), control_len = 0", .sender = sender.socket_name)'// создаётся загружаемый буффер
    sender.socket_used_buffer := sender.socket_used_buffer + get_msg_len(msg) // отмечается изменение использованного пространства буффера данного сокета
    sender.socket_cur_buffer_cnt++ // отмечается изменения количество созданных буфферов
    
    for (i in [0..msg.msg_iovlen]) {
        memcpy(to_void_pointer(to_char_pointer(buf.buf_data) + buf.data_len), to_void_pointer(to_char_pointer(msg.msg_iov[i].iov_base)), msg.msg_iov[i].iov_len)
        buf.data_len := buf.data_len + msg.msg_iov[i].iov_len // Увеличивается размер данных в буффере
    }
    
    if (msg.msg_controllen != 0) { // есть дополнительные данные
        def cmsg : cmsghdr* := CMSG_FIRSTHDR(msghdr)   
            
        while (cmsg != to_cmsghdr_pointer(NULL)) {
            if (cmsg->cmsg_type == SCM_RIGHTS) { // передаются файловые дескрипторы
                def fd_arr : Nat* := to_nat_pointer(cmsg->cmsg_data)
                def fds_cnt : Nat := (cmsg->cmsg_len - sizeof('cmsghdr')) / sizeof('Int') 
            
                for (j in [0..fds_cnt]) {
                    def cur_fd : Nat := \deref(fd_arr + j)
                    fd_open_file = get_open_file(current, cur_fd)
                    fd_open_file.of_ref_cnt++
                    add_to_list(buf.of_arr, fd_open_file)
                }
            } 
            # SCM_CREDENTIALS -> nothing to do
            # SCM_SECURITY -> TODO
            
            cmsg := CMSG_NXTHDR(msg, cmsg)
        }
        
        memcpy(buf.buf_control_data, msg.msg_control, msg.msg_controllen) // Копируются дополнительные данные в буффер
        buf.control_len := msg.msg_controllen // Устанавливается размер дополнительных данных  
    } else { // нет дополнительных данных
        buf.buf_control_data := NULL // В буфере отмечается, что массив дополнительных данных пуст
        buf.control_len := 0 //Устанавливается размер дополнительных данных
    }
    
    add_to_list(reciver.socket_buf, buf)
    
    return buf.data_len
end
    attr algorithm: 'Алгоритм загрузки данных'



logical is_possible_to_load_data
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    sender     @IN  : Socket
    reciver    @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Ждём освобождение места в буффера отправителя. (sender.socket_cur_buffer_cnt < max_msg_cnt(sender) && get_msg_len(msg) <= socket.socket_so_sndbuf * 2 - socket.socket_used_buffer)


#TODO:
logical CMSG_FIRSTHDR
params
    msg @IN  : msghdr*
    ret @OUT : cmsghdr*
function
    return to_cmsghdr_pointer(msg->msg_control)
end
    attr text: 'первый заголовок дополнительных данных в сообщении {msg}'


logical CMSG_NXTHDR
params
    msg  @IN  : msghdr*
    cmsg @IN  : cmsghdr*
    res  @OUT : cmsghdr*
function
    if (to_char_pointer(cmsg) + cmsg->cmsg_len + 1 - CMSG_FIRSTHDR(msg) >= msg->msg_controllen) {
        return to_cmsghdr_pointer(NULL)
    }

    return to_cmsghdr_pointer(to_char_pointer(cmsg + cmsg->cmsg_len))
end
    attr text: 'следующий заголовок дополнительных данных после {cmsg} в сообщении {msg}'



const SCM_MAX_FD : Nat := 253 // SCM_MAX_FD 

type Ucred : struct 
{
    Int pid;
    Uid uid;
    Gid gid;
}
endtype


logical cmsgs_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Error-set
function
    def errors : Error-set := {. .}
    def cur_cmsg : cmsghdr* := CMSG_FIRSTHDR(msg)
    def right_cnt := 0
    def sec_cnt := 0
    def cred_cnt := 0
    
    while (cur_cmsg != to_cmsghdr_pointer(NULL)) {
        if (cur_cmsg->cmsg_level != SOL_SOCKET) {
            add_to_set(errors, EINVAL)
        } 
        
        if (cur_cmsg->cmsg_type == SCM_RIGHTS) {
            right_cnt++
            if (right_cnt > 1) {
                add_to_set(errors, EINVAL)
            }
        
            def fds_cnt : Nat := (cur_cmsg->cmsg_len - sizeof('cmsghdr')) / sizeof('Int') 
        
            if (fds_cnt > SCM_MAX_FD) {
                add_to_set(errors, EINVAL)
            }
            
            fds_arr = to_int_pointer(cur_cmsg->cmsg_data)
            
            forany(i : Nat | i < fds_cnt && \deref(fds_arr + i) \notisin \dom(current.proc_fds)) {
                add_to_set(errors, EBADF)                
            }
        } elif (cur_cmsg->cmsg_type == SCM_CREDENTIALS) {
            cred_cnt++

            if (cred_cnt > 1) {
                add_to_set(errors, EINVAL)
            }

            ucred = to_ucred_pointer(cur_cmsg->cmsg_data)

            if ((forall proc : Process | proc.proc_pid != ucred->pid) || ucred->uid \notisin os.os_users || ucred->gid \notisin os.os_groups) {
                add_to_set(errors, EINVAL)
            }

            if (current.proc_cred.cr_euid != 0 && (ucred->pid != current.proc_pid || (ucred->uid != current.proc_cred.cr_uid && ucred->uid != current.proc_cred.cr_euid && ucred->uid != current.proc_cred.cr_suid) || (ucred->gid != current.proc_cred.cr_gid && ucred->gid != current.proc_cred.cr_egid && ucred->gid != current.proc_cred.cr_sgid))) {
                add_to_set(errors, EACCES)
            }
        } elif (cur_cmsg->cmsg_type == SCM_SECURITY) {
            sec_cnt++
            if (sec_cnt > 1) {
                add_to_set(errors, EINVAL)
            }

            #TODO(?) or empty
        } else {
            add_to_set(errors, EINVAL)
        }
        
        cur_cmsg := CMSG_NXTHDR(msghdr, cur_cmsg)
   }
    
   return errors
end




action sendmsg_generic // sendmsg_generic
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    # at least one ordinary data byte 

    socket = get_sock_data(current, sockfd)
    abs_addr = get_abs_path(current, msg->msg_name, msg->msg_namelen)
    
    if (socket.socket_type == SOCK_DGRAM) {
        other = get_by_address(os, abs_addr)
    } else {
        other = socket.socket_peer
    }

    current.proc_status := S //! Установить атрибуту proc_status текущего процесса значение S.
    wait INFWAIT { // состояние ожидания после вызова функции отправки данных по сокету
        trigger (is_possible_to_load_data(socket, other)) { // произошло освобождение места в буффере отправителя
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            size_of_loaded_data = load_data(current, msg, socket, other)
            socket.socket_peer := other
            return size_of_loaded_data
        }
            
        trigger (interrupt_logical(current, socket)) { // произошло прерывание во время блокировки системного вызова
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            current.proc_errno := EINTR //! Установить атрибуту proc_errno текущего процесса значение EINTR.
            return -1   
        }
    }
end


const SIGPIPE : Nat // SIGPIPE

function sendmsg is
/**
 * @param sockfd IN файловый дескриптор сокета
 * @param msg    IN ссылка на структуру msghdr для передачи
 * @param flags  IN флаги сообщения
 * @return количество отправленных байт в случае успешного выполнения, иначе -1.
 */
ssize_t sendmsg(int sockfd, msghdr *msg, int flags);
end


event sendmsg // вызов функции sendmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    possible_errors = sendmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors = {. .}) {
        if (EPIPE \isin possible_errors) { # По другому не строится граф
            if (MSG_NOSIGNAL \notisin flags) {
                add_to_list(current.proc_pending_signals, SIGPIPE)
            }
        }
    
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
            return -1
        }
    }


    sendmsg_generic(os, current, sockfd, msg, flags)
end
    attr summary-cfg: True
    attr algo-tree: True


function sendto is
/**
 * @param sockfd    IN файловый дескриптор сокета
 * @param buf       IN буффер с собщением
 * @param len       IN размера буфера
 * @param flags     IN флаги сообщения
 * @param dest_addr IN адрес получателя
 * @param addrlen   IN размер адреса получателя
 * @return количество отправленных байт в случае успешного выполнения, иначе -1.
 */
ssize_t sendto(int sockfd, void *buf, size_t len, int flags, sockaddr *dest_addr, socklen_t addrlen);
end



event sendto // вызов функции sendto
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags
    dst      @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int    
function
    #sendto TODO если получатель не указан установить получаетля peer'ом

    msg = 'mk_msg(.msg_name = dst->address, .msg_name_len = addrlen, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = sendmsg_errors(os, current, sockfd, \ref(msg), flags)
    
    if (possible_errors = {. .}) {
        if (EPIPE \isin possible_errors) { # По другому не строится граф
            if (MSG_NOSIGNAL \notisin flags) {
                add_to_list(current.proc_pending_signals, SIGPIPE)
            }
        }
    
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
            return -1
        }
    }

    
    sendmsg_generic(os, current, sockfd, \ref(msg), flags)
end
    attr summary-cfg: True
    attr algo-tree: True

function send is
/**
 * @param sockfd IN файловый дескриптор сокета
 * @param buf    IN буффер с собщением
 * @param len    IN размера буфера
 * @param flags  IN флаги сообщения
 * @return количество отправленных байт в случае успешного выполнения, иначе -1.
 */
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
end


event send // вызов функции send
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    socket123 = get_sock_data(current, sockfd) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = sendmsg_errors(os, current, sockfd, \ref(msg), flags)
    
    if (possible_errors = {. .}) {
        if (EPIPE \isin possible_errors) { # По другому не строится граф
            if (MSG_NOSIGNAL \notisin flags) {
                add_to_list(current.proc_pending_signals, SIGPIPE)
            }
        }
    
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
            return -1
        }
    }

    
    sendmsg_generic(os, current, sockfd, \ref(msg), flags)
end
    attr summary-cfg: True
    attr algo-tree: True

function write is
/**
 * @param fd IN файловый дескриптор сокета
 * @param buf    IN буффер с собщением
 * @param count  IN размера буфера
 * @return количество отправленных байт в случае успешного выполнения, иначе -1.
 */
ssize_t write(int fd, const void *buf, size_t count);
end



event write // // вызов функции write
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Int
    buf     @IN  : void* # void *buf
    count   @IN  : Nat
    ret     @OUT : Int
invariant current.proc_fds(sockfd).fd_open_file_ref->of_type == SOCKET_TYPE
function
    socket123 = get_sock_data(current, sockfd) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(msg_name = socket123.socket_peer.socket_address, msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = &{buf, count}, msg_control = 0, msg_controllen = 0, msg_flags = 0)'
    
    possible_errors = sendmsg_errors(os, current, sockfd, \ref(msg), \emptyset)
    
    if (possible_errors = {. .}) {
        if (EPIPE \isin possible_errors) { # По другому не строится граф
            add_to_list(current.proc_pending_signals, SIGPIPE)
        }
    
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
            return -1
        }
    }

    
    sendmsg_generic(os, current, sockfd, \ref(msg), \emptyset)
end
    attr summary-cfg: True
    attr algo-tree: True


logical min
params
    lhs @IN  : Int
    rhs @IN  : Int
    res @OUT : Int
function
    if (lhs < rhs) {
        return lhs
    } else {
        return rhs
    }
end
    attr text: 'минимум из {lhs} и {rhs}'
    
    
logical max
params
    lhs @IN  : Int
    rhs @IN  : Int
    res @OUT : Int
function
    if (lhs > rhs) {
        return lhs
    } else {
        return rhs
    }
end
    attr text: 'максимум из {lhs} и {rhs}'


event memcpy
params
    T   @TYPE
    dest @IN   : T*
    src  @IN   : T*
    n    @IN   : Nat
function
    dest_char = to_char_pointer(dest)
    src_char = to_char_pointer(src)
    
    for (i in [0..n]) {
        dest_char[i] := src_char[i]
    }
    #* Скопировать n байт из адреса src в адрес dest.
end
    attr algorithm: 'Алгоритм реализующий функцию memcpy из библиотеки СИ'



event get_cmsg_data
params
    os      @IN  : OS
    current @IN  : Process // текущий процесс
    reciver @IN  : Socket
    msg     @IN  : msghdr*
    flags   @IN  : MsgFlags
    buf     @IN  : sk_buff  
function
    def cmsg : cmsghdr* := to_cmsghdr_pointer(buf.buf_control_data)
    def cmsg_copied : Nat := 0

    while (cmsg != to_cmsghdr_pointer(NULL)) {
        if (cmsg->cmsg_type == SCM_RIGHTS) { // дополнительное сообщение передаёт файловые дескрипторы (cmsg->cmsg_type = SCM_RIGHTS)
            going_to_copy = min(cmsg->cmsg_len, msg->msg_controllen - cmsg_copied)
            data_bytes = max(going_to_copy - sizeof('cmsghdr'), 0)
            fds_to_pass = data_bytes / sizeof('Int')
            
            if (fds_to_pass < \len(buf.of_arr)) { // число принимаемых файловых дескрипторов меньше чем число переданных
                add_to_set(msg->msg_flags, MSG_CTRUNC)
            }
            
            if (fds_to_pass > 0) {
                memcpy(to_void_pointer(to_char_pointer(msg->msg_control) + cmsg_copied), to_void_pointer(cmsg->cmsg_data), sizeof('cmsghdr')) // Скопировать заголовок дополнительных данных
                cmsg_copied := cmsg_copied + sizeof('cmsghdr')
                         
                for (k1 in [0..fds_to_pass]) {
                    def fd : Nat := generate_fd(current)
                    current.proc_fds(fd) := 'mk_Fd(.fd_open_file_ref=buf.of_arr(k1), .fd_flags={. .})'
                    buf.of_arr(k1).of_ref_cnt++ // Увлечить количество ссылок на файл
                    if (MSG_CMSG_CLOEXEC \isin flags) {
                        current.proc_fds(fd).fd_flags := {. FD_CLOEXEC .}
                    }
                    
                    \deref(to_int_pointer(to_char_pointer(msg->msg_control) + cmsg_copied)) := fd // Скопировать созданный файловый дескриптор
                    cmsg_copied := cmsg_copied + sizeof('Int')
                }
            }        
        } elif (cmsg->cmsg_type == SCM_CREDENTIALS && SO_PASSCRED \isin reciver.socket_flags) { // cmsg->cmsg_type = SCM_CREDENTIALS b SO_PASSCRED принадлежит reciver.socket_flags
            if (cmsg->cmsg_len > msg->msg_controllen - cmsg_copied) { // в буфере нет места
                add_to_set(msg->msg_flags, MSG_CTRUNC)
            } else {
                memcpy(to_void_pointer(to_char_pointer(msg->msg_control) + cmsg_copied), to_void_pointer(cmsg), cmsg->cmsg_len)
                cmsg_copied := cmsg_copied + cmsg->cmsg_len
            }            
        } elif (cmsg->cmsg_type == SCM_SECURITY && SO_PASSSEC \isin reciver.socket_flags) { // cmsg->cmsg_type == SCM_SECURITY и SO_PASSSEC принадлежит reciver.socket_flags
            if (cmsg->cmsg_len > msg->msg_controllen - cmsg_copied) { // в буфере нет места
                add_to_set(msg->msg_flags, MSG_CTRUNC)
            } else {
                memcpy(to_void_pointer(to_char_pointer(msg->msg_control) + cmsg_copied), to_void_pointer(cmsg), cmsg->cmsg_len)
                cmsg_copied := cmsg_copied + cmsg->cmsg_len
            }  
        }
        
        cmsg := CMSG_NXTHDR(msg, cmsg)
    }
    
    msg->msg_controllen := cmsg_copied // Устанавливается размер дополнительных данных
end
    attr algorithm: 'Алгоритм получения дополнительных данных'



event get_data
params
    os      @IN  : OS
    current @IN  : Process // текущий процесс
    reciver @IN  : Socket
    msg     @IN  : msghdr*
    flags   @IN  : MsgFlags
    ret     @OUT : Nat
function
    def copied : Nat := 0 // Обозначить число считанных байт
    def i : Nat := 0
    

    if (reciver.socket_type == SOCK_DGRAM || reciver.socket_type == SOCK_SEQPACKET) { // сокет использует датаграмнный ввод/вывод (recvier.socket_type  -= SOCK_DGRAM || recvier.socket_type = SOCK_SEQPACKET)      
        buf = reciver.socket_buf(0) // первый пришедшый буффер
        def sender : Socket := get_by_address(os, buf.sender) // Вычислим отправителя
        if (msg->msg_name != to_char_pointer(NULL)) { // нужно указать адрес отпарвителя
            msg->msg_name := to_char_arr(sender.socket_name) // Изменяем значение пользовательского буфера на адрес отправителя
            msg->msg_namelen := reciver.socket_peer.socket_addrlen // Изменяем значение размера пользовательского буфера
        }

        while (i < msg->msg_iovlen && buf.consumed < buf.data_len) {
            iov = msg->msg_iov[i]
            
            memcpy(iov.iov_base, buf.buf_data + buf.consumed, min(iov.iov_len, buf.data_len - buf.consumed)) // Скопировать данные
            copied := copied + min(iov.iov_len, buf.data_len - buf.consumed)
            buf.consumed := buf.consumed + min(iov.iov_len, buf.data_len - buf.consumed)
            
            if (min(iov.iov_len, buf.data_len - buf.consumed) == iov.iov_len) {
                i++
            }
        }  
        
        if (buf.control_len != 0) { // есть дополнительные данные
            get_cmsg_data(os, current, reciver, msg, flags, buf) // Копируются дополнительный данные
        } else {
            msg->msg_control := NULL 
            msg->msg_controllen := 0
        }
                
        if (buf.consumed != buf.data_len) { // считана не вся датаграмма
            add_to_set(msg->msg_flags, MSG_TRUNC)
        }
        
        if (MSG_PEEK \notisin flags) { // читали не в режиме подсматривания
            sender.socket_used_buffer := sender.socket_used_buffer - buf.data_len // Освобождается память в буфере отправителя для последующих сообщений
            sender.socket_cur_buffer_cnt-- // Уменьшается число инициализированных отправителем буферов
            del_from_list(reciver.socket_buf) // Прочитанная датаграмма удаляется
        } else {
            buf.consumed := buf.consumed - copied
        }
        
        if (reciver.socket_type == SOCK_DGRAM && MSG_TRUNC \isin flags) {
            return buf.data_len // вернуть настоящий размер датаграммы
        } else {
            return copied // вернуть число считанных байт
        }
    } else {// ввод/вывод потоковый (recvier.socket_type == SOCK_STREAM)
        def cur_iov_base_size : Nat := 0 // Обозначить количество считаных для текущего iov вектора байт
        def cur_buf_to_read : Nat := 0 // Обозначить количетсво считанных буфферов
        def beg_buf_consumed : Nat := reciver.socket_buf(0).consumed // Сохранить количество потреблённых данных в первом буфере
        if (msg->msg_name != to_char_pointer(NULL)) { // нужно указать адрес отпарвителя 
            msg->msg_name := to_char_arr(reciver.socket_peer.socket_name) // Изменяем значение пользовательского буфера на адрес отправителя
            msg->msg_namelen := reciver.socket_peer.socket_addrlen // Изменяем значение размера пользовательского буфера
        }
        
        while (i < msg->msg_iovlen && cur_buf_to_read < \len(reciver.socket_buf)) { // есть буффер для чтения
            buf = reciver.socket_buf(cur_buf_to_read)
            
            def cur_stream_copied : Nat := 0
           
            while (i < msg->msg_iovlen && buf.consumed < buf.data_len) { // буфер не считан полностью
                iov = msg->msg_iov[i]
            
                bytes_to_copy = min(iov.iov_len - cur_iov_base_size, buf.data_len - buf.consumed)
                
                memcpy(to_void_pointer(to_char_pointer(iov.iov_base) + cur_iov_base_size), to_void_pointer(to_char_pointer(buf.buf_data) + buf.consumed), bytes_to_copy) // Скопировать данные в буфер
                cur_stream_copied := cur_stream_copied + bytes_to_copy
                cur_iov_base_size := cur_iov_base_size + bytes_to_copy
                buf.consumed := buf.consumed + bytes_to_copy
            
                if (cur_iov_base_size == iov.iov_len) { // был считан весь iov вектор
                    cur_iov_base_size := 0
                    i++
                }
            }
            
            copied := copied + cur_stream_copied
            
            if (buf.buf_control_data != NULL && buf.consumed == buf.data_len) { // Если есть дополнительные данные
                get_cmsg_data(os, current, reciver, msg, flags, buf) // Копируются дополнительный данные
                
                goto endRead // остановить копирование
            } elif (buf.consumed == buf.data_len) { 
                cur_buf_to_read++
            }
        }
        
endRead:       
        if (MSG_PEEK \isin flags) { // чтение без удаления из буфера
            reciver.socket_buf(0).consumed := beg_buf_consumed // Востановить значение потреблённых данных в первом буфере
        
            for (k in [1..cur_buf_to_read]) {
                reciver.socket_buf(k).consumed := 0 // Установить значение потреблённых данных равным нуля в буфере
            }
        } else { // чтение с удалением
            for (l in [0..cur_buf_to_read - 1]) {
                buf = reciver.socket_buf(0) // Берём l-ый буфер 
            
                other = get_by_address(os, buf.sender)
                other.socket_used_buffer := other.socket_used_buffer - buf.data_len // Освобождается память в буфере отправителя для последующих сообщений
                other.socket_cur_buffer_cnt-- // Уменьшается число инициализированных буферов сокета-отправителя
                
                for (k1 in [0..\len(socket_buf(0).of_arr)]) {
                    socket_buf(0).of_arr(k1).of_ref_cnt-- // Удалить ссылки на открытые файла для передаваемые буффера 
                }
                
                del_from_list(socket_buf) // Прочитанный буфер удаляется
            }
            
            if (socket_buf(0).consumed == socket_buf(0).data_len) { // последний буфер был потреблён полностью
                buf = reciver.socket_buf(0) // Берём последний буфер
                other = get_by_address(os, buf.sender)
                other.socket_used_buffer := other.socket_used_buffer - buf.data_len // Освобождается память в буфере отправителя для последующих сообщений
                other.socket_cur_buffer_cnt-- // Уменьшается число инициализированных отправителем буферов
                
                for (h in [0..\len(socket_buf(0).of_arr)]) {
                    socket_buf(0).of_arr(h).of_ref_cnt-- // Удалить ссылки на открытые файла для передаваемые буффера 
                }
                
                del_from_list(socket_buf) // Прочитанный буфер удаляется
            }
        }
        
        return copied     
   }
end
    attr algorithm: 'Алгоритм получения данных'



logical msg_have_come
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
end
    attr event-desc: Появилось сообщения для считывания в буффере. (server.socket_buf != <. .>))



action recvmsg_generic
params
    os          @IN : OS
    current     @IN : Process
    sockfd      @IN : Nat
    msg         @IN : msghdr*
    flags       @IN : MsgFlags
    paddrlen    @IN : Nat*
function
    socket = get_sock_data(current, sockfd)
    
    current.proc_status := S //! Установить атрибуту proc_status текущего процесса значение S.
    wait INFWAIT { // состояние ожидания после вызова функции получения данных из сокета
        trigger (msg_have_come(socket)) { // появилось сообщения для считывания в буффере
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            res = get_data(os, current, socket, msg, flags)
            
            return res
        }
        
        trigger (interrupt_logical(current, socket)) { // произошло прерывание во время блокировки системного вызова
            current.proc_errno := EINTR //! Установить атрибуту proc_errno текущего процесса значение EINTR.
            current.proc_status := R //! Установить атрибуту proc_status текущего процесса значение R.
            return -1   
        }
    }
end
    attr summary-cfg: True
    attr algo-tree: True
    

function recvmsg is
/**
 * @param sockfd IN файловый дескриптор сокета
 * @param msg    IN ссылка на структуру msghdr для приёма
 * @param flags  IN флаги сообщения
 * @return количество считанных байт в случае успешного выполнения, иначе -1.
 */
ssize_t recvmsg(int sockfd, msghdr *msg, int flags);
end


event recvmsg // вызов функции recvmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    possible_errors = recvmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    recvmsg_generic(os, current, sockfd, msg, flags, \ref(msg->msg_namelen))
end
    attr summary-cfg: True
    attr algo-tree: True


function recvfrom is
/**
 * @param sockfd   IN файловый дескриптор сокета
 * @param buf      IN буффер для приёма собщения
 * @param len      IN размера буфера
 * @param flags    IN флаги сообщения
 * @param src_addr IN адрес, который нужно заполнить отправителем
 * @param addrlen  IN размер отправителя
 * @return количество считанных байт в случае успешного выполнения, иначе -1.
 */
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, sockaddr *src_addr, socklen_t *addrlen);
end


event recvfrom // вызов функции recvfrom 
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : Nat-set
    src      @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Int  
function
    msg = 'mk_msg(.msg_name = src->address, .msg_name_len = \deref(addrlen), .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = recvmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }
    
    recvmsg_generic(os, current, sockfd, msg, flags, addrlen)
end
    attr summary-cfg: True
    attr algo-tree: True


function recv is
/**
 * @param sockfd IN файловый дескриптор сокета
 * @param buf    IN буффер для приёма сообщения
 * @param len    IN размера буфера
 * @param flags  IN флаги сообщения
 * @return количество считанных байт в случае успешного выполнения, иначе -1.
 */
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
end


event recv // вызов функции recv
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags
    ret      @OUT : Int  
function
    socket123 = get_sock_data(current, sockfd)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = Nothing, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = recvmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }
    
    recvmsg_generic(os, current, sockfd, msg, flags, to_nat_pointer(NULL))
end
    attr summary-cfg: True
    attr algo-tree: True
    

function read is
/**
 * @param fd     IN файловый дескриптор сокета
 * @param buf    IN буффер для приёма собщения
 * @param count  IN размера буфера
 * @return количество считанных байт в случае успешного выполнения, иначе -1.
 */
ssize_t read(int fd, void *buf, size_t count);
end


event read // вызов функции read
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void*
    count   @IN  : Nat  
    ret     @OUT : Int
invariant current.proc_fds(sockfd).fd_open_file_ref->of_type == SOCKET_TYPE
function
    socket123 = get_sock_data(current, sockfd)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = recvmsg_errors(os, current, sockfd, msg, \emptyset)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }
    
    recvmsg_generic(os, current, sockfd, msg, \emptyset, to_nat_pointer(NULL))
end
    attr summary-cfg: True
    attr algo-tree: True



action truncate_address
params
    addr     @IN : sockaddr_un*
    addr_len @IN : Nat
function
    * Заполнить всю структуру addr с размером addr_len нулями
end


function getpeername is
/**
 * @param sockfd  IN файловый дескриптор сокета
 * @param addr    IN ссылка на адрес, который нужно заполнить
 * @param addrlen IN размер адреса
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int getpeername(int sockfd, sockaddr *addr, socklen_t *addrlen);
end


event getpeername // вызов функции getpeername
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : sockaddr_un*
    addrlen @IN  : Nat*
    ret     @OUT : Int
function
    possible_errors = getpeername_errors(os, current, sockfd, address, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (\deref(addrlen) >= socket.socket_peer.socket_addrlen) { // в переданном буфере достаточно места
        address->sun_family := AF_UNIX
        address->sun_path := to_char_arr(socket.socket_peer.socket_name)
    } else { # Buffer is too small
        truncate_address(address, \deref(addrlen)) # Truncate address
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end
    attr summary-cfg: True
    attr algo-tree: True


function getsockname is
/**
 * @param sockfd  IN файловый дескриптор сокета
 * @param addr    IN ссылка на адрес, который нужно заполнить
 * @param addrlen IN размер адреса
 * @return 0 в случае успешного выполнения, иначе -1.
 */
int getsockname(int sockfd, sockaddr *addr, socklen_t *addrlen);
end


event getsockname // вызов функции getsockname
params
    os      @IN  : OS
    current @IN  : Process // текущий процесс
    sockfd  @IN  : Nat
    address @IN  : sockaddr_un*
    addrlen @IN  : Nat*
    ret     @OUT : Int
function
    possible_errors = getsockname_errors(os, current, sockfd, address, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (\deref(addrlen) > socket_addrlen) { // в переданном буффере достаточно места
        address->sun_family := AF_UNIX
        address->sun_path := to_char_arr(socket.socket_name)
    } else { 
        truncate_address(address, \deref(addrlen)) 
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end
    attr summary-cfg: True
    attr algo-tree: True



const POSSIBLE_SOCKET_TYPES : SockType-set-set // Множество корректных типов сокета {. SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET .} >< {. SOCK_NONBLOCK .} >< {. SOCK_CLOEXEC .}. Тип сокета (SOCK_STREAM, SOCK_DGRAM, SOCK_RDM etc), и (опционально) флаги SOCK_NONBLOCK или SOCK_CLOEXEC. Т.е. либо тройка, либо двойка, либо только тип сокета (SOCK_STREAM etc).
const MAX_FDS_PER_PROC : Nat // Максимальное число файловых дескрипторов для одного процесса
const MAX_OPEN_FILES   : Nat // Максимальное число открытых файлов в системе. Это число может быть найдено, например, в файле /proc/sys/fs/file-max



logical set_len
params
  T    @TYPE
  setP @IN : T-set
  res  @OUT: Nat
end
  attr text: Количество элементов в множестве {setP}


logical socket_errors // сокращение для получения множество вохможноых ошибок, при заданных входных данных для системного вызова socket.
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set // Почему-то SOCK_STREAM | SOCK_DGRAM в AF_UNIX успешно создает SOCK_DGRAM сокет...
    protocol  @IN  : Protocol
    errors    @OUT : Error-set
function

    return {. errcode for errcode : Error | (errcode == EACCES) && False || # EACCES не нашёл где возникает, кроме случая с андроид
    (errcode == EAFNOSUPPORT) && (domain != AF_UNIX) ||
    (errcode == EPROTONOSUPPORT) && (protocol != PF_UNIX && protocol != 0) || 
    (errcode == EINVAL) && (sock_type \notisin POSSIBLE_SOCKET_TYPES) || 
    (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
    (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
    (errcode == ENOBUFS) && False || # Не знаю как, поэтому не специфицирую
    (errcode == ENOMEM) && False ||  # Не знаю как, поэтому не специфицирую 
    (errcode == ESOCKTNOSUPPORT) && (sock_type \intersect {. SOCK_STREAM .} == {. .} || sock_type \intersect {. SOCK_DGRAM .} == {. .} && sock_type \intersect {. SOCK_SEQPACKET .} == {. .}) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции socket с параметрами {domain}, {sock_type}, {protocol}'



logical bind_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    abs_path = get_abs_path(current, sockaddr->sun_path, addrlen)
    
    return {. errcode for errcode : Error | (errcode == EACCES) && (abs_path(0) != "\0" && !access_to_write(os, current, abs_path)) ||
        (errcode == EADDRINUSE) && (abs_path \isin \dom(os.os_socket_table)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINVAL) && (socket.socket_addrlen != 0 || (addrlen != sizeof('sockaddr_un') && addrlen != sizeof('sa_family_t'))) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EADDRNOTAVAIL) && (False) || 
        (errcode == EFAULT) && (False) ||
        (errcode == ELOOP) && (False) || # Todo
        (errcode == ENAMETOOLONG) && (addrlen >= PATH_MAX) || 
        (errcode == ENOENT) && (\len(get_files_in_path(os, abs_path)) == 0) || #Одной из директорий в пути для данного адреса не существует
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTDIR) && (!is_all_files_in_path_dirs(os, current, abs_path)) || 
        (errcode == EROFS) && (False) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции bind с параметрами {sockfd}, {sockaddr}, {addrlen}'


logical listen_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)

    # У unix socket eaddrinuse не возникает
    return {. errcode for errcode : Error | (errcode == EADDRINUSE) && (socket.socket_address \isin \dom(os.os_socket_table)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type == SOCK_DGRAM).}
end    
    attr text: 'множество ошибок, которые должны произойти при вызове функции listen с параметрами {sockfd}, {backlog}'



logical connect_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat
    server   @IN  : Socket
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EACCES) && (socket.socket_address(0) != "\0" && !access_to_write(os, current,  socket.socket_address)) || 
        (errcode == EPERM) && (False) || 
        (errcode == EADDRINUSE) && (socket.socket_address \isin \dom(os.os_socket_table)) || 
        (errcode == EADDRNOTAVAIL) && (False) || 
        (errcode == EAFNOSUPPORT) && (sockaddr.sun_family != AF_UNIX) ||
        (errcode == EAGAIN) && (O_NONBLOCK \isin openfile.of_flags && \len(server.socket_queue) < server.socket_backlog) || 
        (errcode == EALREADY) && (False) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNREFUSED) && (server.socket_status != LISTEN) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EISCONN) && (socket.socket_status == CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EPROTOTYPE) && (socket.socket_type != server.socket_type) || 
        (errcode == ETIMEDOUT) && (False) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции connect с параметрами {sockfd}, {sockaddr}, {addrlen}'



logical accept_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set    
function
#If address is not a null pointer, the address of the peer for the accepted connection shall be stored in the sockaddr structure pointed to by address, and the length of #this address shall be stored in the object pointed to by address_len.

#If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address shall be truncated.
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EAGAIN) && (O_NONBLOCK \isin openfile.of_flags && socket.socket_queue == <..>) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNABORTED) && (False) || 
        (errcode == EFAULT) && (False) ||
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un') || socket.socket_status != LISTEN || RCV_SHUTDOWN \isin socket.socket_shutdown_flags) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type != SOCK_STREAM && socket.socket_type != SOCK_SEQPACKET) || 
        (errcode == EPROTO) && (False) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции connect с параметрами {sockfd}, {sockaddr}, {addrlen}'



logical accept4_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat*
    flags    @IN  : SockType-set
    ret      @OUT : Error-set    
function
#If address is not a null pointer, the address of the peer for the accepted connection shall be stored in the sockaddr structure pointed to by address, and the length of #this address shall be stored in the object pointed to by address_len.

#If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address shall be truncated.
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EAGAIN) && (O_NONBLOCK \isin openfile.of_flags && socket.socket_queue == <..>) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNABORTED) && (False) || 
        (errcode == EFAULT) && (False) ||
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un') || socket.socket_status != LISTEN || RCV_SHUTDOWN \isin socket.socket_shutdown_flags) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type != SOCK_STREAM && socket.socket_type != SOCK_SEQPACKET) || 
        (errcode == EPROTO) && (False) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции accept4 с параметрами {sockfd}, {sockaddr}, {addrlen}, {flags}'


logical close_errors
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Error-set
function    
    return {. errcode for errcode : Error | (errcode == EBADF) && (fd \notisin \dom(current.proc_fds)) || 
        (errcode == EINTR) && (False) || 
        (errcode == EIO) && (False) || 
        (errcode == ENOSPC) && (False) || 
        (errcode == EDQUOT) && (False).}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции close с параметрами {fd}'


logical shutdown_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINVAL) && (how != SHUT_RD && how != SHUT_WR && how != SHUT_RDWR) || 
        (errcode == ENOTCONN) && (socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции shutdown с параметрами {sockfd}, {how}'


logical socketpair_errors
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fds       @IN  : Int*
    ret      @OUT : Error-set
function    
    return {. errcode for errcode : Error | (errcode == EAFNOSUPPORT) && (domain != AF_UNIX) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC - 1) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES - 1) ||
        (errcode == EOPNOTSUPP) && (protocol != PF_UNIX && protocol != PF_UNSPEC) || 
        (errcode == EPROTONOSUPPORT) && (protocol != PF_UNIX && protocol != PF_UNSPEC) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции socketpair с параметрами {domain}, {sock_type}, {protocol}, {fds}'


logical getpeername_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    address  @IN  : sockaddr_un*
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un')) || 
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOTCONN) && (socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции getpeername с параметрами {sockfd}, {address}, {addrlen}'


logical getsockname_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    address  @IN  : sockaddr_un*
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set
function
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un')) || 
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end
    attr text: 'множество ошибок, которые должны произойти при вызове функции getsockname с параметрами {sockfd}, {address}, {addrlen}'


logical recvmsg_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    if (msg->msg_namelen == 0) {
        sender_path = socket.socket_peer.socket_address
        sender = socket.socket_peer
    } else {
        sender_path = get_abs_path(current, msg->msg_name, msg->msg_namelen)
        sender = get_by_address(os, sender_path)
    }

    
    # ENOTSOCK last in recvmsg
    return {. errcode for errcode : Error | (errcode == EAGAIN) && ((O_NONBLOCK \isin openfile.of_flags || MSG_DONTWAIT \isin flags) && socket.socket_buf == <. .>) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNREFUSED) && (socket.socket_addrlen == 0) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (MSG_OOB \isin MsgFlags || msg->msg_controllen > MAX_ANCILLARY_BUFFER) || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTCONN) && ((socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) && socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == ENOTCONN) && (msg->msg_namelen == 0 && socket.socket_status != CONNECTED) ||
        (errcode == EPROTOTYPE) && (socket.socket_type != sender.socket_type) .}
end
    attr text: 'множество ошибок, которые должны произойти при чтении из сокета с параметрами {sockfd}, {msg}, {flags}'


logical sendmsg_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    if (msg->msg_namelen == 0) {
        reciver_path = socket.socket_peer.socket_address
        reciver = socket.socket_peer
    } else {
        reciver_path = get_abs_path(current, msg->msg_name, msg->msg_namelen)
        reciver = get_by_address(os, reciver_path)
    }

    # EPIPE - последний в sendmsg
    res1 = {. errcode for errcode : Error | (errcode == EACCES) && (!access_to_write(os, current, reciver_path)) || 
        (errcode == EAGAIN) && ((O_NONBLOCK \isin openfile.of_flags || MSG_DONTWAIT \isin flags) && (socket.socket_cur_buffer_cnt == max_msg_cnt(socket) || get_msg_len(msg) > socket.socket_so_sndbuf * 2 - socket.socket_used_buffer)) || 
        (errcode == EALREADY) && (False) || # for internet socket only 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EDESTADDRREQ) && ((msg->msg_namelen == 0 && socket.socket_status == CONNECTED) || (msg.msg_namelen != 0 && reciver_path \notisin \dom(os.os_socket_table))) || 
        (errcode == EFAULT) && (False) ||  
        (errcode == EINVAL) && (MSG_OOB \isin flags || msg->msg_controllen > MAX_ANCILLARY_BUFFER) ||  
        (errcode == EISCONN) && (msg->msg_namelen != 0 && (socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) && socket.socket_status == CONNECTED) ||  
        (errcode == EMSGSIZE) && (get_msg_len(msg) > socket.socket_so_sndbuf) ||  
        (errcode == ENOBUFS) && (False) ||  
        (errcode == ENOMEM) && (False) ||  
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) ||  
        (errcode == EPIPE) && (SEND_SHUTDOWN \isin socket.socket_shutdown_flags || RCV_SHUTDOWN \isin reciver.socket_shutdown_flags) || 
        (errcode == ECONNRESET) && (socket.socket_peer.socket_address \notisin \dom(os.os_socket_table)) ||
        (errcode == ENOENT) && (\len(get_files_in_path(os, reciver_path)) == 0) ||
        (errcode == ENOTCONN) && (msg.msg_namelen == 0 && socket.socket_status != CONNECTED) ||
        (errcode == EPROTOTYPE) && (socket.socket_type != reciver.socket_type) .}
    
    res2 = cmsgs_errors(os, current, sockfd, msg, flags) # ESRCH, EPERM, EINVAL
    
    return res1 \union res2
end
    attr text: 'множество ошибок, которые должны произойти при записи в сокет с параметрами {sockfd}, {msg}, {flags}'


event get_files_in_path
params
    os   @IN  : OS
    path @IN  : Text
    res  @OUT : File-list
function
    def res_list : File-list := <. .>
    
    for (i in [0..\len(path)]) {
        if (path(i) == "/") {
            def file_abs_path : Text := ""
            cur_file = os.os_files(i)
            
            for (k in [0..i]) {
                file_abs_path(k) := path(k)
            }
            
            def was_found : Bool := False
            def j : Nat := 0
            while ('j < \len(os.os_files) && !was_found') {
                
                if (cur_file.file_path == file_abs_path) {
                    was_found := True
                }
                
                j++
            }
            
            if (was_found) {
                add_to_list(res_list, cur_file)
            } else {
                res_list := <. .>
                return res_list
            }
        }
    }

    return res_list
end
    attr algorithm: 'Алгоритм выделения файлов в пути'


logical groupmember
params
    gid   @IN  : Gid
    cred  @IN  : Cred
    ret   @OUT : Bool
function
    if (gid == cred.cr_egid) {
        return True
    } else {
        forany(group : Gid | group \isin cred.cr_groups) {
            if (group == gid) {
                return True
            } else {
                return False
            }
        }
    }
end


logical access
params
    os          @IN  : OS
    current     @IN  : Process
    access_type @IN  : RequstedAccessType
    file        @IN  : File
    ret         @OUT : Bool
function
    cred = current.proc_cred
    fcred = file.file_cred
    ftype = file.file_type
    
    if (cred.cr_euid == 0) {
        return (access_type == EXEC && ftype != DIRECTORY_TYPE && (fcred.fc_permission \intersect {. S_IXUSR, S_IXGRP, S_IXOTH .} != {. .}))
    } else {       
        if (cred.cr_euid == fcred.fc_uid) {
            if (access_type == EXEC) {
                mask = {. S_IXUSR .}
            } elif (access_type == READ) {
                mask = {. S_IRUSR .}
            } else {
                mask = {. S_IWUSR .}
            }
        } elif (groupmember(fcred.fc_gid, cred)) {
            if (access_type == EXEC) {
                mask = {. S_IXGRP .}
            } elif (access_type == READ) {
                mask = {. S_IRGRP .}
            } else {
                mask = {. S_IWGRP .}
            }
        } else {
            if (access_type == EXEC) {
                mask = {. S_IXGRP .}
            } elif (access_type == READ) {
                mask = {. S_IRGRP .}
            } else {
                mask = {. S_IWGRP .}
            }
        }
        
        return (fcred.fc_permission \intersect mask) == mask
    }
end


logical is_all_files_in_path_dirs
params
    os      @IN  : OS
    current @IN  : Process
    path    @IN  : Text
    res     @OUT : Bool
function
    files = get_files_in_path(os, path)
    
    for (i in [0..\len(files) - 1]) {
        if (files(i).file_type != DIRECTORY_TYPE) {
            return False
        }
    }
    
    return True
end


logical access_to_write
params
    os      @IN  : OS
    current @IN  : Process
    path    @IN  : Text
    res     @OUT : Bool
function
    files = get_files_in_path(os, path)
    
    if (\len(files) == 0) {
        return True # это другая ошибка
    } else {
        for (i in [0..\len(files) - 1]) {
            if (access(os, current, EXEC, files(i))) {
                return False
            }
        }
        
        if (!access(os, current, WRITE, files(\len(files) - 1))) {
            return False
        }
    }
    
    return True
end


logical sizeof
  params
    T   @IN      @CTYPE
    res @OUT   : Int # size_t
end
  attr text: 'sizeof({T})'

note 'OBJTREE_NOTE' is
@objtree[root:OS]@
endnote
endmodule
