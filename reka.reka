# 3 перевода строки - разделение между объектами/событиями
# 1 перевода строки разделение между атрибутами
module 'Абстрактные модели'
  attr target_object: 'система'

#import everything from types
#import logicals from errors 
#Types#

type Uid : Nat // численный индефикатор пользователя
type Gid : Nat // численный индефикатор группы

type Gids : Gid-set
type Uids : Uid-set


type Permission:
enum
    S_IRUSR                       
    S_IWUSR                        
    S_IXUSR                   
    S_IRGRP
    S_IWGRP
    S_IXGRP
    S_IROTH
    S_IWOTH
    S_IXOTH
endtype


type Permissions : Permission-set


type Cred : struct
{
    Uid cr_uid;            // Real user id
    Uid cr_euid;           // Effective user id
    Uid cr_suid;           // saved effective user id.
    Gid cr_gid;            // Real group id 
    Gid cr_egid;           // effective group id
    Gid cr_sgid;           // Saved effective group id
    Int cr_ngroups;       // number of groups
    Gids cr_groups;     // groups
    Permissions cr_umask;    // umask
}
is
**Cred** - структура, хранящая информацию о правах процесса
endtype



type Fcred : struct
{
    Uid fc_uid;
    Gid fc_gid;
    Permissions fc_permission;
}
endtype

# Раздел сигналов - Beg
#type Handler  -- не нужно
#type Handler3 -- не нужно
type Sigset : Nat-set
type SignalFlag: # Мне достаточно описать SA_RESTART
enum
    SA_RESTART // Перезапустить определённый системный вызов.
endtype
type SignalFlags : SignalFlag-set

type Sigaction : struct
{
    #Handler hand; // Обработчик с одним параметром.
    #Handler3 sigact; // Обработчик с 3мя параметрами.
    SignalFlags signal_flags; // Флаги сигналов.
    #Sigset sigset; // contains a bitmask with exactly one bit for each signal available in the system. It is used to block other signals during execution of the handler routine. Мне это не нужно.
}
is
**Sigaction** - структура, описывающая работу с сигналами. 
endtype
# Раздел сигналов - End

type ProcStatus:
enum
    R // running or runnable (on run queue)
    S // interruptible sleep (waiting for an event to complete) (В этом состоянии процесc при блокировке)
is
**ProcStatus** - перечислимый тип, содержащий статус текущего процесса:
$enumdefs$
endtype

type FdFlag: 
enum
    FD_CLOEXEC // close on exec
is
**FdFlag** - тип для флагов, которые приписаны к файловому дескриптору на уровне конкретного процесса:
$enumdefs$
endtype

type FileType:
enum
    REGULAR_FILE_TYPE // обычный файл
    DIRECTORY_TYPE    // директория
    SOCKET_TYPE       // сокет
is
**FileType** - перечислимы тип, описывающий типы файлов:
$enumdefs$
endtype

type OpenFileFlag :
enum
    O_RDONLY  // доступ на чтение
    O_WRONLY  // доступ на запись
    O_RDWR    // доступ и на чтение, и на запись
    O_NONBLOCK  // запрет блокировки
is
**OpenFileType** перечисление флагов открытых файлов:
$enumdefs$
endtype

type sk_buff : struct 
{
    void* buf_data; // буффер в котором передаются данные
    Nat data_len; // количество байт данных
    Nat consumed; // количество прочитанных байт данных (Нужно для SOCK_STREAM).
    void* buf_control_data; // буффер дополнительных данных
    Nat control_len; // количетсво байт дополнительных данных
    Text sender; // адрес отправителя
}
is
**sk_buff** - данные внутри каждого буффера. Для *SOCK_DGRAM* и *SOCK_SEQPACKET*, можно сказать, предстваляет получаемую датаграмму. Для *SOCK_STREAM* буфферы будут читаться последовательно, отмечая уже прочитанные данные, учёт которых происходит в *consumed*. При *consumed* == *len* буффер считается полностью прочитанным и удаляется из очереди. 
endtype

type SocketStatus:
enum
    UNCONNECTED
    CONNECTING
    CONNECTED
    LISTEN
    LISTENING
    TCP_CLOSED 
is
**SocketStatus** - перечисление, в которых может находится сокет. 
endtype

type SocketFlag: 
enum
       SO_ACCEPTCONN
       SO_ATTACH_FILTER //(since Linux 2.2)
       SO_ATTACH_BPF //(since Linux 3.19)
       SO_ATTACH_REUSEPORT_CBPF
       SO_ATTACH_REUSEPORT_EBPF
       SO_BINDTODEVICE
       SO_BROADCAST
       SO_BSDCOMPAT // Уже не поддерживается
       SO_DEBUG
       SO_DETACH_FILTER //(since Linux 2.2)
       SO_DETACH_BPF //(since Linux 3.19)
       SO_DOMAIN
       SO_ERROR
       SO_DONTROUTE
       SO_INCOMING_CPU //(gettable since Linux 3.19, settable since Linux 4.4)
       SO_KEEPALIVE
       SO_LINGER
       SO_LOCK_FILTER
       SO_MARK //(since Linux 2.6.25)
       SO_OOBINLINE
       SO_PASSCRED
       SO_PASSSEC 
       SO_PEEK_OFF //(since Linux 3.4)
       SO_PEERCRED
       SO_PRIORITY
       SO_PROTOCOL //(since Linux 2.6.32)
       SO_RCVBUF // Does not have effect in unix socket (buf callable?)
       SO_RCVBUFFORCE //(since Linux 2.6.14)
       SO_RCVLOWAT
       SO_SNDLOWAT
       SO_RCVTIMEO
       SO_SNDTIMEO
       SO_REUSEADDR
       SO_REUSEPORT// (since Linux 3.9)
       SO_RXQ_OVFL //(since Linux 2.6.33)
       SO_SNDBUF
       SO_SNDBUFFORCE// (since Linux 2.6.14)
       SO_TIMESTAMP
       SO_TIMESTAMPNS
       SO_TIMESTAMPING
       SO_TYPE
       SO_BUSY_POLL //(since Linux 3.11)
is
**SocketFlag** - перечесление флагов сокета.    
end

type SocketFlags : SocketFlag-set

type SockType: # Чтобы закинуть, к примеру SOCK_NONBLOCK и SOCK_STREAM в один set. Пусть будет один тип.
enum
    SOCK_STREAM
    SOCK_DGRAM
    SOCK_SEQPACKET
    SOCK_RAW
    SOCK_RDM
    SOCK_PACKET
    SOCK_NONBLOCK
    SOCK_CLOEXEC
is
**SockType** - перечисление типов сокетов.
endtype

type ShutdownFlags:
enum
    RCV_SHUTDOWN   // Сокет не может читать 
    SEND_SHUTDOWN  // Сокет не может писать
endtype

type AddressFamily:
enum
    AF_UNIX // == AF_LOCAL
    AF_UNSPEC
is 
**AddressFamily** - перечесление семейств адрессов. В данной модели рассматривается только *AF_UNIX*. 
 
$enumdefs$
endtype

type Protocol:
enum
    PF_UNIX // == PF_LOCAL
    PF_UNSPEC
is
**Protocol** - протоколы:

$enumdefs$
endtype

type Error: 
enum
    ENOTCONN
    ECONNABORTED
    EACCES
    EAFNOSUPPORT
    EINVAL
    EMFILE
    ENFILE
    ENOBUFS
    ENOMEM
    EPROTONOSUPPORT
    EBADF
    ENOTSOCK
    EINVAL
    EROFS
    EFAULT
    ENAMETOOLONG
    ENOENT
    ENOMEM
    ENOTDIR
    EACCES
    ELOOP
    ESOCKTNOSUPPORT
    EADDRINUSE
    EADDRNOTAVAIL
    EOPNOTSUPP
    EINTR
    EIO
    ENOSPC
    EDQUOT
    EPERM
    EAGAIN
    EALREADY
    ECONNREFUSED
    EINPROGRESS
    EISCONN
    ENETUNREACH
    EPROTOTYPE
    ETIMEDOUT
    EAGAIN
    ECONNABORTED
    EPROTO
is
**Error** - перечисление всех кодов ошибок, которые могут возникать в событиях.
endtype

type Sockaddr_un : struct
{
    AddressFamily sun_family;
    Text sun_path;
}
is
**Sockaddr_un** - соотвествующая си структура, которая передаётся, например, в *bind*.
endtype

type ShutdownParam:
enum
    SHUT_RD
    SHUT_WR
    SHUT_RDWR
is
**ShutdownParam** - перечисление возможных значений параметра *how* в систменов вызове *shutdown*
endtype


type Level:
enum
    SOL_SOCKET
is
**SOL_SOCKET** - опции для всех сокетов или опции только юниксовых соектов
end

type MsgFlags:
enum
    MSG_CONFIRM
    MSG_DONTROUTE
    MSG_DONTWAIT
    MSG_EOR
    MSG_TRUNC
    MSG_CTRUNC
    MSG_ERRQUEUE
    MSG_MORE // Unix socket does not support this flag 
    MSG_NOSIGNAL
    MSG_OOB // Unix socket does not support this flag
is
*MsgFlgas* - тип всех флагов для функций sendto, recvfrom
endtype

type iovec : struct {
    void* iov_base;
    Nat iov_len;
}
is
**iovec** - iovec для msghndr
endtype

type ioveclist : iovec-list

type msghdr : struct {
    Text      msg_name;
    Nat       msg_namelen;
    ioveclist msg_iov;
    Nat       msg_iovlen;
    void*     msg_control;
    Nat       msg_controllen;
    Int       msg_flags;
}
is
**msghdr** - структура для sendmsg/recvmsg
endtype



type RequstedAccessType:
enum
    READ
    WRITE
    EXEC
endtype

#TypesEnd

object OS is 
**OS** - объект, представляющий систему целиком
end

objattr os_open_file_table : OpenFile-set is
**os_open_file_table** - таблица открытых файлов ОС. В этой таблице происходит регистрация всех открытых в системе файлов.
end

objattr os_files : File-set is
**os_files** - множество всех файлов в файловой системе.
end

objattr os_proceses : Process-set is 
**Proos_procesescesses** - множество процессов в системе.
end

objattr os_socket_table : Text -m-> Socket is
**os_socket_table** - отображение адресса unix сокета (т.е. строки) в сокет с таким адресом.
end

objattr os_users : Uid-set is
**os_users** - множество всех пользователей, зарегистрированных в системе. (/etc/passwd)
end

objattr os_groups : Gid-set is
**os_groups** - множество всех пользователей, зарегистрированных в системе. (/etc/group)
end
endobject



object Process is
**Process** - отдельный процесс ОС.
end

objattr proc_pid : Int is
**proc_pid** - уникальный индефикатор процесса.
end

objattr proc_errno : Int is
**proc_errno** - атрибут, хранящий целочисленный код последней ошибки.
end

objattr proc_fds : Nat -m-> Fd is 
**proc_fds** - таблица открытых файловых дескрипторов процесса.
end

objattr proc_cred : Cred is
**proc_cred** - информация о правах процесса.
end

objattr proc_sigaction_array : Nat -m-> Sigaction is # sighand_struct === k_sigaction[_NSIG] === proc_sigaction_array
**proc_sigaction_array** - информация об обработчиках процесса. Отображение номера сигнала в # (обработку сигналов не прикручивал)
end

objattr proc_pending_signals : Nat-list is # Это более расширеная структура с информацией о том от кого пришло и т.д. т.е. с полем 'siginfo_t info';
**proc_pending_signals** - номера сигналов, пришедших на обработку. 
end

objattr proc_blocked_signals : Sigset is # Nat есть здесь, если сигнал блокируется. В реальности это битовая маска, но я пока сигналы их номером описываю.
**proc_blocked_signals** - в этом множестве находятся номера сигналов, которые блокируются.
end

objattr proc_status : ProcStatus is 
**proc_status** - текущее состояние процесса
end
endobject



object Fd is
**Fd** - файловый дескриптор.
end

objattr fd_open_file_ref : OpenFile* is 
**fd_open_file_ref** - ссылка на структуру с информацией об открытом файле.
end

objattr fd_flags : FdFlag-set is # Хотя возможен только один
**fd_flags** - флаги, которые приписаны к файловому дескриптору на уровне конкретного процесса.
end
endobject

object File is
**File** - объект, представляющий файл в ФС
end

objattr file_path : Text is
**file_path** - абсолютный путь до файла.
end

objattr file_type : FileType is
**file_type** - тип файла.
end

objattr file_cred : Fcred is
**file_cred** - Информация об обладателе и правах доступа
end
endobject



object OpenFile is 
**OpenFile** хранит информацию об открытом файле. Например, такие данные, как флаги доступа, оступ в файле и т.д..
end

# Бывший of_op_type - операции определённые для этого типа. Этим хотелось выразить наличия поля op в стркутуре откртытого файла, с целью различения типов открытых файлов. Здесь он просто равен типу файлу.
objattr of_type : FileType is
**of_type** - тип открытого файла. # Дублирует тип File. Дублирование необходимо т.к. файла для сокета в ФС ещё может не быть, но подсмотреть тип файла для описание ошибочных ситуаций нужно.  
end

objattr of_file : File* is
**of_file** - хранит ссылку на соотвестующий этому **OpenFile**, объект **File**.
end

objattr of_ref_cnt : Int is
**of_ref_cnt** - число ссылающихся на эту запись файловых дескрипторов.
end

objattr of_flags : OpenFileFlag-set is # Как-то не точно описано, но усложнять не хочется. (не точность в возможности присутствия одновременно O_RDONLY, и O_WRONLY, и O_RDWR, хотя в реальности возможно наличие только одного из них)  
**of_flags** - флаги открытого файла. 
end

objattr of_private_data : Socket-ref is
**of_private_data** - ссылка на важные структура данных. (Здесь находится ссылка на структуру сокет).
end
endobject



object Socket is 
**Socket** - объект представляющий собой UNIX сокет.
end

objattr socket_status : SocketStatus is
**socket_status** - текущий статус сокета
end

objattr socket_address : Text is
**socket_address** - адрес сокета.
end

objattr socket_addrlen : Nat is
**socket_addrlen** - длина адреса сокета.
end

objattr socket_queue : Socket-list is 
**socket_queue** - очередь для accept.
end

objattr socket_backlog : Int is
**socket_backlog** - длина очереди полностью настроенных сокетов, которые ждут принятия.
end

objattr socket_peer : Socket-ref is
**socket_peer** - ссылка на сокета-друга, с котором б общение.
end

objattr socket_flags : SocketFlags is
**socket_flags** - флаги сокета. Осуществлять управление этими флагами можно с помощью *setsockopt* и  *getsockopt*
end

objattr socket_type : SockType is
**socket_type** - тип сокета.
end

objattr socket_shutdown_flags : ShutdownFlags-set is
**socket_shutdown_flags** - флаги, обозначающие закрытие на операции чтения и записи, выполняемые этим сокетом. 
end

objattr socket_buf : sk_buff-list is
**socket_buf_list** - буффер сокета.
end

objattr socket_so_sndbuf : Nat is
**socket_so_buff** - размер буффера сокета. Значение, получаемое getsockopt() с SO_SNDBUF
end

objattr socket_used_buffer : Nat is
**socket_used_buffer** - уже использованный количество байт буффера.
end

objattr socket_cur_buffer_cnt : Nat is
**socket_cur_buffer_cnt** - количество уже выделенных буфферов.
end
endobject



const DEFAULT_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_default
const MAX_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_max


logical to_sockaddr_ref
params
    prm1 @IN  : void*
    ret  @OUT : Sockaddr_un-ref
function
    * Преобразует указатель в Sockaddr_un-ref
end



logical to_nat_ref
params
    prm1 @IN  : void*
    ret  @OUT : Nat*
function
    * Преобразует указатель в Nat*
end



action add_to_list // Добавить элемент в список l (по стратегии fifo).
params
    T @TYPE
    l @IN : T-list
    el   @IN : T
function 
    l(\len l) := el
end



logical get_list_head // Взять первый элемент списка l с удалением.
params
    T    @TYPE
    l    @IN  : T-list
    el   @OUT : T
function
    * Взять первый элемент списка l с удалением.
end



action del_from_list // Удалить элемент idx из списка l.
params
    T    @TYPE
    fifo @IN  : T-list
    idx  @IN  : Nat
function
    * Удалить элемент idx из списка l.
end



action add_to_set
params
  T     @TYPE
  set1  @IN    : T-set
  el    @IN    : T
function
  set1 := set1 ∪ {. el .} // !Добавить el в set1
end



action remove_from_set
params
  T    @TYPE
  set1 @IN   : T-set
  el   @IN   : T
function
  set1 := set1 \diff {. el .}
end 



# Для сокращения записи
logical get_sock_data // получить структуру данных для процесса current и сокета sockfd.
params
    current @IN  : Process
    sockfd  @IN  : Nat
    sock    @OUT : Socket
function
    return current.proc_fds(sockfd).fd_open_file_ref->of_private_data
end


# Для сокращения
logical get_by_address
params
    os        @IN  : OS
    sock_addr @IN  : Text
    sock      @OUT : Socket
function 
    return os.os_socket_table(sock_addr)
end 



# Для сокращения записи
logical get_open_file // получить открытый файл для процесс current и сокета fd.
params
    current @IN  : Process
    fd      @IN  : Nat
    opefile @OUT : OpenFile
function
    return \deref(current.proc_fds(fd).fd_open_file_ref)
end

action add_to_map
params
  T1    @TYPE
  T2    @TYPE
  map   @IN    : T1 -m-> T2
  key   @IN    : T1
  el    @IN    : T2
function
    map(key) := el // !Добавить el в map с ключом key
end



action remove_from_map
params
  T1  @TYPE
  T2  @TYPE
  map @IN : T1 -m-> T2
  key @IN : T1
function
    * Удалить элемент key из map
end


const NULL : void*
const Nothing // Константа для неинициализированных частей

event socket // socket
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fd        @OUT : Int
invariant domain == AF_UNIX # Модель только для UNIX сокетов
invariant current \isin os.os_proceses # Текущей процесс существует в рамках системы
function
    possible_errors = socket_errors(os, current, domain, sock_type, protocol)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    forany(newFD : Nat | newFD \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD) => nn \isin \dom(current.proc_fds)) {
    socket = 'mk_socket(.socket_status=UNCONNECTED, .socket_address=Nothing, .socket_addrlen=Nothing, .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(), socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
        
        if (SOCK_STREAM \isin sock_type) {
            socket.socket_type := SOCK_STREAM
        } else if (SOCK_SEQPACKET \isin sock_type) {
           socket.socket_type := SOCK_SEQPACKET
        } else { # SOCK_RAW, SOCK_DGRAM
           socket.socket_type := SOCK_DGRAM
        }
        
        openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket)'    
            
        if (SOCK_NONBLOCK \isin sock_type) {
            add_to_set(openfile.of_flags, O_NONBLOCK)
        }
        
        if (SOCK_CLOEXEC \isin sock_type) {
            newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. FD_CLOEXEC .})'
        } else {
            newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'
        }
        
        add_to_map(current.proc_fds, newFD, newFDObject)
        add_to_set(os.os_open_file_table, openfile)
            
        return newFD
    }
end



const PATH_MAX : Nat // Maximum path size in system


# TODO описать алгоритм. Как я понимаю по итогу это нужно будет описывать с помощью алгоритма.
logical make_path_abs // если сокет абстрактный, то возвращаем путь. Если путь абсолютный, то избавляемся от ., .., символьных ссылок в пути. Если путь относительный, добавляем слева current_cur_path и избавляемся от ., .., символьных ссылок в пути.
params
    current @IN  : Process
    path    @IN  : Text
    abs     @OUT : Text
function
    if (path(0) == '\0') {
        return path
    }
    
    * Если путь абсолютный, то избавляемся от ., .., символьных ссылок в пути. Если путь относительный, добавляем слева current_cur_path и избавляемся от ., .., символьных ссылок в пути.
end

#The abstract socket namespace is a nonportable Linux extension.


const AutoBindAlphabet : Char-set // character set [0-9a-f]



event bind // bind
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : Sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Int
function    
    possible_errors = bind_errors(os, current, sockfd, sockaddr, addrlen)
    
    sock_address = make_path_abs(current, sockaddr->sun_path)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }
    
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    
    if (addrlen == 'sizeof(sa_family_t)') { // Autobind feature -- Linux feature
        forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && \len(newUnixAddress) == 6 && newUnixAddress(0) == '\0' && newUnixAddress(1) \isin AutoBindAlphabet && newUnixAddress(2) \isin AutoBindAlphabet && newUnixAddress(3) \isin AutoBindAlphabet && newUnixAddress(4) \isin AutoBindAlphabet && newUnixAddress(5) \isin AutoBindAlphabet) {
            socket.socket_address := sock_address
            socket.socket_addrlen := 6 # One byte \0 + 5 of autobind address The change to 5 bytes came in Linux 2.3.15.)
            add_to_map(os.os_socket_table, sock_address, socket) // зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
        }
    }

    if (sock_address(0) != '\0') { # Обычный сокет. Абстрактному сокету это не нужно.
        newFile = 'mk_File(.file_path=sock_address, .file_type=SOCKET_TYPE, .file_cred = { fc_uid, .fc_gid, .fc_permissions = {. S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH.} \diff current.proc_cred.cr_umask })' // Создание нового файла
        add_to_set(os.os_files, newFile) // Добавление файла в ФС
        openfile.of_file := newFile // сокет связывается с созданным файлом
    }
    
    socket.socket_address := sock_address
    socket.socket_addrlen := addrlen
    add_to_map(os.os_socket_table, sock_address, socket) // зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
    
    return 0
end



const SOMAXCONN : Nat // значение в /proc/sys/net/core/somaxconn файле



event listen // listen
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Int
function
    possible_errors = listen_errors(os, current, sockfd, backlog)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (backlog > SOMAXCONN) {
        socket.socket_backlog := SOMAXCONN
    } else {
        socket.socket_backlog := backlog
    }
    
    socket.socket_status := LISTEN
        
    return 0
end



logical is_free_space_in_backlog
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появилось место для постановки себя в очередь на подключение (\len(server.socket_queue) < server.socket_backlog)



logical was_accepted
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    socket     @IN  : Socket
    res        @OUT : Bool 
end
    attr event-desc: Запрос на подключение был принят сервером. (socket \notisin server.socket_queue).

event connect // systemcall connect
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int 
function
    socket = get_sock_data(current, sockfd)
    server = get_by_address(os, sockaddr->sun_path)
    
    possible_errors = connect_errors(os, current, sockfd, sockaddr, addrlen, server)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    #Комментарий из кода -> Фича Linux: If possible we block in connect(2) if the max backlog of the listen socket is been reached. This won't break old apps and it will avoid huge amount of socks hashed (this for unix_gc() performances reasons).

    if (socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) {
        socket.socket_status := CONNECTING
        
        current.proc_status := S
        
       
        wait INFWAIT {
            trigger (is_free_space_in_backlog(server)) { // текст для триггера 1
                current.proc_status := R
                add_to_list(server.socket_queue, socket) 
            }
            
            trigger (interrupt_logical(current, socket)) { // текст для триггера 2
                current.proc_errno := EINTR
                current.proc_status := R
                return -1
            }
        }
        
        current.proc_status := S
        
        wait INFWAIT {
            trigger (was_accepted(server, socket)) { // текст для триггера 1
                #socket.socket_status := CONNECTED -- устанавливает это сервер (в accept)
                #socket.socket_peer := -- устанавливает это сервер.
                del_from_list(server.socket_queue, 0)
                current.proc_status := R
            }
                
            trigger (interrupt_logical(current, socket)) { // текст для триггера 2
                # Описать подчищивание надо? я про верхний wait. TODO(??)
                current.proc_errno := EINTR
                current.proc_status := R
                return -1
            }
        }
    } else {
        socket.socket_peer := \ref(server)
        socket.socket_status := CONNECTED
    }
    
    return 0    
end



logical backlog_is_not_empty
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появился запрос на подключение (server.socket_queue != <..>)




#On Linux, the new socket returned by accept() does not inherit file status flags such as O_NONBLOCK and O_ASYNC from the listening socket. В POSIX об этом ничего нет.
event accept // accept
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Int
function
    possible_errors = accept_errors(os, current, sockfd, sockaddr, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    socket.status := LISTENING
    current.proc_status := S
    
    wait INFWAIT { 
        trigger (backlog_is_not_empty(socket)) { // текст для триггера 1. Есть кого принимать
            current.proc_status := R
            socket.status := LISTEN
            peer = get_list_head(socket.socket_queue) // Тот, кто подсоединяется
            forany(newFD : Nat | newFD \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD) => nn \isin \dom(current.proc_fds)) { // Создаются fd, OpenFile, Socket. Причём все поля у новых OpenFile и Socket такие же, как и у этих же объектов соотвестующих sockfd. 
                forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && newUnixAddress(0) == '\0') {
                    new_socket = 'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress, .socket_addrlen=\len(newUnixAddress), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=peer, .socket_flags={. .}, .socket_type=socket.socket_type, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=socket.socket_so_sndbuf, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                
                    peer.socket_peer := new_socket
                    peer.socket_status := CONNECTED
                    
                    if (sockaddr != to_sockaddr_ref(NULL)) { //sockaddr != NULL
                        * strncmp(\ref(\deref(sockaddr).sun_path), \ref(newUnixAddress), min(\len(newUnixAddress, \deref(addrlen)))
                        \deref(addrlen) := \len(newUnixAddress)      
                    }

                    openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, of_flags={. O_RDWR .}, .of_private_data=socket)'    
                    newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'

                    add_to_map(current.proc_fds, newFD, newFDObject)
                    add_to_set(os.os_open_file_table, openfile)
                    add_to_map(os.os_socket_table, new_socket.socket_address, new_socket)
                
                    return newFD   
                }
            } 
        }
            
        trigger (interrupt_logical(current, socket)) { // текст для триггера 2
            current.proc_errno := EINTR
            current.proc_status := R
            socket.status := LISTEN
            
            return -1   
        }
    }
end



event close // close (описывался к применнию только для fd сокета)
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Int
invariant current.proc_fds(fd).fd_open_file_ref.of_ref_cnt >= 1// Если у файла ref_cnt == 0, то его в этой таблице быть не должно 
invariant current.proc_fds(fd).fd_open_file_ref.of_type == SOCKET_TYPE// Вызов рассматривается только для сокетов
function
    possible_errors = close_errors(os, current, fd)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, fd)
    open_file = get_open_file(current, fd)

    remove_from_map(current.proc_fds, fd)
    open_file.of_ref_cnt--
 
    if (open_file.of_ref_cnt == 0) {
        socket.socket_peer.socket_status := TCP_CLOSED
        remove_from_set(os.os_open_file_table, open_file)
        remove_from_map(os.os_socket_table, socket.socket_address)
    }
    
    return 0
end



event shutdown // shutdown
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Int
function
    possible_errors = shutdown_errors(os, current, sockfd, how)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    peer = socket.socket_peer

    if (how == SHUT_RD) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)  
    } elif (how == SHUT_WR) {
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    } elif (how == SHUT_RDWR) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    }
    
    return 0    
end



event socketpair // socketpair
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol-set
    fds       @IN  : Nat -m-> Nat
    fd        @OUT : Int
function
    possible_errors = socketpair_errors(os, current, domain, sock_type, protocol, fds)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    forany(newFD1 : Nat | newFD1 \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD1) => nn \isin \dom(current.proc_fds)) {
        forany(newFD2 : Nat | newFD2 \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD2) => nn \isin \dom(current.proc_fds)) {
            forany(newUnixAddress1 : Text | newUnixAddress1 \notisin \dom(os.os_socket_table) && newUnixAddress1(0) == '\0') {
                forany(newUnixAddress2 : Text | newUnixAddress2 \notisin \dom(os.os_socket_table) && newUnixAddress2(0) == '\0') {
                    socket1 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress1, .socket_addrlen=\len(newUnixAddress1), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                    socket2 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress2, .socket_addrlen=\len(newUnixAddress2), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                    socket1.socket_peer := socket2
                    socket2.socket_peer := socket1
                    
                    
                    
                    if (SOCK_STREAM \isin sock_type) {
                        socket1.socket_type := SOCK_STREAM
                        socket2.socket_type := SOCK_STREAM
                    } elif (SOCK_SEQPACKET \isin sock_type) { 
                        socket1.socket_type := SOCK_SEQPACKET
                        socket2.socket_type := SOCK_SEQPACKET
                    } else { # SOCK_DGRAM, SOCK_RAW
                        socket1.socket_type := SOCK_DGRAM
                        socket2.socket_type := SOCK_DGRAM
                    } 
                    
                    openfile1 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket1)'
                    openfile2 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket2)'    
                        
                    if (SOCK_NONBLOCK \isin sock_type) {
                        add_to_set(openfile1.of_flags, O_NONBLOCK)
                        add_to_set(openfile2.of_flags, O_NONBLOCK)
                    }
                    
                    if (SOCK_CLOEXEC \isin sock_type) {
                        newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. FD_CLOEXEC .})'
                        newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. FD_CLOEXEC .})'
                    } else {
                        newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. .})'
                        newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. .})'
                    }
                    
                    add_to_map(current.proc_fds, newFD1, newFDObject1)
                    add_to_map(current.proc_fds, newFD2, newFDObject2)
                    add_to_set(os.os_open_file_table, openfile1)
                    add_to_set(os.os_open_file_table, openfile2)
                    add_to_map(os.os_socket_table, newUnixAddress1, socket1)
                    add_to_map(os.os_socket_table, newUnixAddress2, socket2)

                    fds(0) := newFD1
                    fds(1) := newFD2
                    
                    return 0
                }
            }
        }
    }

end

############## IO part start ###########

#TODO
event getsockopt
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    level   @IN  : Level
    optname @IN  : SocketFlag
    optval  @IN  : void*
    optlen  @IN  : Nat*
    ret     @OUT : Int
function
    if (optname == SO_ACCEPTCONN) {
    } elif (optname == SO_ATTACH_FILTER) {
    } elif (optname == SO_ATTACH_BPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
    } elif (optname == SO_BINDTODEVICE) {
    } elif (optname == SO_BROADCAST) {
    } elif (optname == SO_BSDCOMPAT) {
    } elif (optname == SO_DEBUG) {
    } elif (optname == SO_DETACH_FILTER) {
    } elif (optname == SO_DETACH_BPF) {
    } elif (optname == SO_DOMAIN) {
    } elif (optname == SO_ERROR) {
    } elif (optname == SO_DONTROUTE) {
    } elif (optname == SO_INCOMING_CPU) {
    } elif (optname == SO_KEEPALIVE) {
    } elif (optname == SO_LINGER) {
    } elif (optname == SO_LOCK_FILTER) {
    } elif (optname == SO_MARK) {
    } elif (optname == SO_OOBINLINE) {
    } elif (optname == SO_PASSCRED) {
    } elif (optname == SO_PASSSEC) {
    } elif (optname == SO_PEEK_OFF) {
    } elif (optname == SO_PEERCRED) {
    } elif (optname == SO_PRIORITY) {
    } elif (optname == SO_PROTOCOL) {
    } elif (optname == SO_RCVBUF) {
    } elif (optname == SO_RCVBUFFORCE) {
    } elif (optname == SO_RCVLOWAT) {
    } elif (optname == SO_SNDLOWAT) {
    } elif (optname == SO_RCVTIMEO) {
    } elif (optname == SO_SNDTIMEO) {
    } elif (optname == SO_REUSEADDR) {
    } elif (optname == SO_REUSEPORT) {
    } elif (optname == SO_RXQ_OVFL) {
    } elif (optname == SO_SNDBUF) {
    } elif (optname == SO_SNDBUFFORCE) {
    } elif (optname == SO_TIMESTAMP) {
    } elif (optname == SO_TIMESTAMPNS) {
    } elif (optname == SO_TYPE) {
    } elif (optname == SO_BUSY_POLL) {
    } elif (optname == SO_TIMESTAMPING) {
    }
    
    return 0
end


#TODO
event setsockopt
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    level   @IN  : Level
    optname @IN  : SocketFlag
    optval  @IN  : void*
    optlen  @IN  : Nat
    ret     @OUT : Int
function
    #if (optname == SO_ACCEPTCONN) - не settable
    if (optname == SO_ATTACH_FILTER) {
    } elif (optname == SO_ATTACH_BPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
    } elif (optname == SO_BINDTODEVICE) {
    } elif (optname == SO_BROADCAST) {
    } elif (optname == SO_BSDCOMPAT) {
    } elif (optname == SO_DEBUG) {
    } elif (optname == SO_DETACH_FILTER) {
    } elif (optname == SO_DETACH_BPF) {
    } elif (optname == SO_DOMAIN) {
    } elif (optname == SO_ERROR) {
    } elif (optname == SO_DONTROUTE) {
    } elif (optname == SO_INCOMING_CPU) {
    } elif (optname == SO_KEEPALIVE) {
    } elif (optname == SO_LINGER) {
    } elif (optname == SO_LOCK_FILTER) {
    } elif (optname == SO_MARK) {
    } elif (optname == SO_OOBINLINE) {
    } elif (optname == SO_PASSCRED) {
    } elif (optname == SO_PASSSEC) {
    } elif (optname == SO_PEEK_OFF) {
    } elif (optname == SO_PEERCRED) {
    } elif (optname == SO_PRIORITY) {
    } elif (optname == SO_PROTOCOL) {
    } elif (optname == SO_RCVBUF) {
    } elif (optname == SO_RCVBUFFORCE) {
    } elif (optname == SO_RCVLOWAT) {
    } elif (optname == SO_SNDLOWAT) {
    } elif (optname == SO_RCVTIMEO) {
    } elif (optname == SO_SNDTIMEO) {
    } elif (optname == SO_REUSEADDR) {
    } elif (optname == SO_REUSEPORT) {
    } elif (optname == SO_RXQ_OVFL) {
    } elif (optname == SO_SNDBUF) {
    } elif (optname == SO_SNDBUFFORCE) {
    } elif (optname == SO_TIMESTAMP) {
    } elif (optname == SO_TIMESTAMPNS) {
    } elif (optname == SO_TYPE) {
    } elif (optname == SO_BUSY_POLL) {
    } elif (optname == SO_TIMESTAMPING) {
    }
    
    
    return 0
end



logical interrupt_logical
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    current    @IN  : Process 
    socket     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Прерывание ожидания процесса, из-за прихода сигнала, который не блокируется маской (current.proc_pending_signals != <..> && exists x:Nat | (x \isin current.proc_pending_signals) && (x \notisin curren.proc_blocked_signals)). Если для пришедшего сигнала верно SA_RESTART \isin current.proc_sigaction_array(signum).signal_flags && SO_RCVTIMEO \notisin socket.socket_flags это эквиваленто перезапуску системного вызова т.е. в этом случае res == False, иначе res == True. 



logical max_msg_cnt # Я не знаю как это получить. Оно зависит от SO_SNDBUF текущего сокета => Параметр - сокет-отправитель
params
    sock @IN  : Socket
    ret  @OUT : Nat
function
    // Как-то связано с so_sndbuf. Как это посчитать не знаю
end



event get_msg_len
params
    msg @IN  : msghdr
    res @OUT : Nat
function
    def _res : Nat := 0

    for (i in [0..msg.msg_iovlen]) {
        _res := _res + msg.msg_iov(i).iov_len
    }
    
    return _res
end
    attr algorithm: 'Алгоритм, считающий размер данных в msg'



#TODO: убрать memcpy
event load_data
params
    msg     @IN  : msghdr
    sender  @IN  : Socket
    reciver @IN  : Socket
function
    buf = 'mk_skbuff(".buf_data = alloc_ptr(), .data_len = 0, .consumed = 0, buf_control_data = alloc_prt(), control_len = 0", .sender = sender.socket_name)' // Устанавливается адрес отправителя
    sender.socket_used_buffer := sender.socket_used_buffer + get_msg_len(msg) //(Отмечается изменение использованного пространства буффера данного сокета)
    sender.socket_cur_buffer_cnt++
    
    for (i in [0..msg.msg_iovlen]) {
        // Данные просматриваются последовательно и загружаются подряд
        * memcpy(buf.buf_data + buf.data_len, msg.msg_iov(i).iovbase, msg.msg_iov(i).iov_len) # Описываю будто адрессная арифметика с void* работает 1 байт
        // Устанавливается общий размер данных (поле data_len)
        buf.data_len := buf.data_len + msg.msg_iov(i).iov_len
    }
    
    if (msg.msg_controllen != 0) {
        //Если есть дополнительные данные, они загружаются
        * memcpy(buf.buf_control_data, msg.msg_control, msg.msg_controllen) 
        // Устанавливается размер дополнительных данных  
        buf.control_len := msg.msg_controllen
    } else {
        // Если их нет, то буффер == null
        buf.buf_control_data := NULL
        //Устанавливается размер дополнительных данных
        buf.control_len := 0
    }
    
    add_to_list(reciver.socket_buf, buf)

end
    attr algorithm: 'Алгоритм загрузки данных'



logical is_possible_to_load_data
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    sender     @IN  : Socket
    reciver    @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Ждём освобождение места в буффера отправителя. (sender.socket_cur_buffer_cnt < max_msg_cnt(sender) || get_msg_len(msg) < socket.socket_so_sndbuf / 2 - socket.socket_used_buffer)



action sendmsg_generic // sendmsg_generic
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr-ref
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    socket = get_sock_data(current, sockfd)
    other = get_by_address(os, msg->msg_name)

    current.proc_status := S
    wait INFWAIT {
        trigger (is_possible_to_load_data(socket, other)) {//сообщение для тригерра 1
            current.proc_status := R
            load_data(msg, socket, other)
        }
            
        trigger (interrupt_logical(current, socket)) { // сообщение для триггера 2
            current.proc_errno := EINTR
            current.proc_status := R
            return -1   
        }
    }
    
    
    socket.socket_peer := other
    return 0
end


#If a blocked call to one of the following interfaces is
#interrupted by a signal handler, then the call is automatically
#restarted after the signal handler returns if the SA_RESTART flag
#was used; otherwise the call fails with the error EINTR:

#read, write, Socket interfaces: accept(2), connect(2), recv(2), recvfrom(2),
#recvmmsg(2), recvmsg(2), send(2), sendto(2), and sendmsg(2),
#unless a timeout has been set on the socket (see below).

#The following interfaces are never restarted after being
#interrupted by a signal handler, regardless of the use of
#SA_RESTART; they always fail with the error EINTR when
#interrupted by a signal handler:

#* "Input" socket interfaces, when a timeout (SO_RCVTIMEO) has
#been set on the socket using setsockopt(2): accept(2), recv(2),
#recvfrom(2), recvmmsg(2) (also with a non-NULL timeout
#argument), and recvmsg(2).

#"Output" socket interfaces, when a timeout (SO_RCVTIMEO) has
#been set on the socket using setsockopt(2): connect(2),
#send(2), sendto(2), and sendmsg(2).



event sendmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr-ref
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    # sendmsg TODO если получатель не указан установить получаетля peer'ом
    sendmsg_generic(os, current, sockfd, msg, flags)
end

event sendto //sendto
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags-set
    dst      @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int    
function
    #sendto TODO если получатель не указан установить получаетля peer'ом

    msg = 'mk_msg(.msg_name = dst->address, .msg_name_len = addrlen, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    sendmsg_generic(os, current, sockfd, \ref(msg), flags)
end



event send // send
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    socket123 = get_sock_data(current, sockfd) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    sendmsg_generic(os, current, sockfd, \ref(msg), flags)
end



event write // write
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void* # void *buf
    count   @IN  : Nat
    ret     @OUT : Int
function
    socket123 = get_sock_data(current, sockfd) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(msg_name = socket123.socket_peer.socket_address, msg_name_len = socket123.socket_peer.socket_address_len, ioveclist = &{buf, count}, msg_control = 0, msg_controllen = 0, msg_flags = 0)'
    
    sendmsg_generic(os, current, sockfd, \ref(msg), \emptyset)
end

#seqpacket в io ~ dgram
event min
params
    lhs @IN  : Int
    rhs @IN  : Int
    res @OUT : Int
function
    if (lhs < rhs) {
        return lhs
    } else {
        return rhs
    }
end
    attr algorithm: 'Алгоритм получения минимального среди двух Int.'


#TODO доделать (get_by_address в алгоритме не работает) + memcpy
event get_data
params
    os      @IN  : OS
    reciver @IN  : Socket
    msg     @IN  : msghdr-ref
    ret     @OUT : Nat
function
    def copied : Nat := 0
    def i : Nat := 0
    def iov : iovec

    if (reciver.socket_type == SOCK_DGRAM || reciver.socket_type == SOCK_SEQPACKET) {
        # Копируется первый пришедший буффер
        # Первый пришедший буффер копируется в msg.msg_iov, последовательно заполняя буфееры в msg.msg_iov. Если буфер больше суммарной длинные iov, то оставшиеся данные в буффере игнорируются
        # Если в первом буффере есть дополнительные данные, они копируются, с установлением их длинны
        # Этот буффер удаляется из socket.socket_buf
        # Отмечается освожодение памяти для отправителя после считывания буффера
        # Возвращает число считанных данных
        # в msg.msg_name загружается адрес отправителя (если изначального буффера не хватает, msg_name зануляется и устанавливается кореектный размер в msg.msg_namelen
        # в msg.msg_namelen длина адреса отправителя

        
        buf = reciver.socket_buf(0) // Первая пришедшая датаграмма
        'sender = get_by_address(os, buf.sender)' // Отправитель

        while ('i < msg->msg_iovlen && buf.consumed < buf.data_len') { #TODO while с двумя условиями
            iov := msg->msg_iov(i)
            cur_dgram_copied = min(iov.iov_len,  buf.data_len - buf.consumed)
            
            * copied := copied + memcpy(iov.iov_base, buf.buf_data + buf.consumed, cur_dgram_copied)
            
            buf.consumed := buf.consumed + cur_dgram_copied
            
            if (cur_dgram_copied == iov.iov_len) {
                i++
            }
        }
        
        if (buf.control_len != 0) {
            //Если есть дополнительные данные, они загружаются
            * memcpy(\ref(msg->msg_control), \ref(buf.buf_control_data), min(msg.msg_controllen, buf.control_len))
            // Устанавливается размер дополнительных данных  
            msg->msg_controllen := min(msg->msg_controllen, buf.control_len)
        } else {
            // Если их нет, то буффер == null
            msg->msg_control := NULL
            //Устанавливается размер дополнительных данных
            msg->msg_controllen := 0
        }
        
        'sender.socket_used_buffer := sender.socket_used_buffer - buf.data_len' // Освобождается память в буффере отправителя для последующих сообщений.
        'sender.socket_cur_buffer_cnt--'
        del_from_list(reciver.socket_buf, 0) // Прочитанная датаграмма удаляется.
        
        return copied
    } else {// recvier.socket_type == SOCK_STREAM
        # Всё, что ниже соотвствует следушющему текстовому описанию:
        # Просматриваются буфферы. Они там в порядке прихода сообщения. Просматриваются до тех пор, пока в сообщении не все буферы заполнены и пока буфферы для считывания есть и пока не встречен буффер с дополнительными данными (если буффер с дополнительными данными присутсвует, то копируются данные и дополнительные данные, устанавливается размер дополнительных данных (в случае чего обрезаются), буфер удаляется и чтение прекращается)
        # Данные из буфферов копируются в msg.msg_iov, последовательно заполняя буфееры в msg.msg_iov
        # Прочитанные полностью буфферы удаляются из socket.socket_buf. Степень прочитанности буффера - sk_buff.consumed
        # Отмечается освожодение памяти для отправителя после считывания буффера
        # Возвращает число считанных данных
        # в msg.msg_name загружается адрес отправителя (если изначального буффера не хватает, msg_name зануляется и устанавливается кореектный размер в msg.msg_namelen
        # в msg.msg_namelen длина адреса отправителя
        
        def cur_iov_base_size : Nat := 0 # cur_len of current iov
        
        while ('i < msg->msg_iovlen && socket.socket_buf != <. .>') {
            buf = reciver.socket_buf(0)
            
            
            def cur_stream_copied : Nat := 0
            # copy one socket buff
            while ('i < msg->msg_iovlen && buf.consumed < buf.data_len') {
                iov := msg->msg_iov(i)
            
                bytes_to_copy = min(iov.iov_len - cur_iov_base_size, buf.data_len - buf.consumed)
                
                cur_stream_copied := cur_stream_copied + bytes_to_copy
                
                # Предполагаю, что адресная арифметика для void* (т.е. iov.iov_base) байтова (void *) + 1 - сдвиг адреса на единицу
                * cur_iov_base_size := cur_iov_base_size + memcpy(iov.iov_base + cur_iov_base_size, buf.buf_data + buf.consumed, bytes_to_copy)
                buf.consumed := buf.consumed + bytes_to_copy
            
                if (cur_iov_base_size == iov.iov_len) {
                    cur_iov_base_size := 0
                    i++
                }
            }
            
            copied := copied + cur_stream_copied
            cur_stream_copied := 0
            
            if (buf.buf_control_data != NULL) { // Если есть дополнительные данные
                // Копируются дополнительный данные
                * memcpy(\ref(msg->msg_control), \ref(buf.buf_control_data), min(msg.msg_controllen, buf.control_len))
                msg.msg_controllen := buf.control_len
                
                // Освобождаются ресурсы
                'get_by_address(os, buf.sender, other)'
                'other.socket_used_buffer := other.socket_used_buffer - buf.data_len'
                'other.socket_cur_buffer_cnt--'
                del_from_list(socket_buf, 0)
                
                //Заверешение иттерации
                return copied  
            } elif (buf.consumed == buf.data_len) {
                'get_by_address(os, buf.sender, other)'
                'other.socket_used_buffer := other.socket_used_buffer - buf.data_len'
                'other.socket_cur_buffer_cnt--'
                del_from_list(socket_buf, 0)
            }
        }
        
        return copied     
   }
end
    attr algorithm: 'Алгоритм получения данных.'



logical msg_have_come
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
end
    attr event-desc: Появилось сообщения для считывания в буффере. (server.socket_buf != <. .>))



action recvmsg_generic
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr-ref
    flags    @IN  : MsgFlags-set
function
    socket = get_sock_data(current, sockfd)
    
    current.proc_status := S
    wait INFWAIT {
        trigger (msg_have_come(socket)) { // Описание триггера 1
            current.proc_status := R
            res = get_data(os, socket, msg)
            
            #if (msg->msg_namelen != 0) { // Это всё в recvfrom TODO
            #    msg->msg_namelen := msg.msg_name
            #    addrlen     := msg.msg_namelen
            #}
            
            return res
        }
        
        trigger (interrupt_logical(current, socket)) { // Описание триггера для прерываний
            current.proc_errno := EINTR
            current.proc_status := R
            return -1   
        }
    }
end



event recvmsg //recvmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr-ref
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    recvmsg_generic(os, current, sockfd, msg, flags)
end


event recvfrom //recvfrom
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : Nat-set
    src      @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Int  
function
    msg = 'mk_msg(.msg_name = src->address, .msg_name_len = \deref(addrlen), .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    recvmsg_generic(os, current, sockfd, msg, flags) #TODOTODO Прямиком скопировать всё из recv_msg_gengeric. Потому что как инчае сделать присваивания в addrlen черезе generic нормально с текущей структурой reka - загадка
end


event recv // recv
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : Nat-set
    ret      @OUT : Int  
function
    socket123 = get_sock_data(current, sockfd)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = Nothing, .msg_controllen = 0, .msg_flags = 0)'
    
    recvmsg_generic(os, current, sockfd, msg, flags)
end



event read // read
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void*
    count   @IN  : Nat  
    ret     @OUT : Int
function
    socket123 = get_sock_data(current, sockfd)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    recvmsg_generic(os, current, sockfd, msg, \emptyset)
end




action truncate_address // Заполнить всю структуру нулями. 
params
    addr    @IN : Sockaddr_un-ref
function
    * Заполнить всю структуру нулями.
end





event getpeername
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : Sockaddr_un-ref
    addrlen @IN  : Nat*
    ret     @OUT : Int
function
    possible_errors = getpeername_errors(os, current, sockfd, address, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (\deref(addrlen) > socket.socket_addrlen) {
        address->sun_family := AF_UNIX
        address->sun_path := socket.socket_peer.socket_address
    } else { // Buffer is too small
        truncate_address(address)        // Truncate address
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end



event getsockname
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : Sockaddr_un-ref
    addrlen @IN  : Nat*
    ret     @OUT : Int
function
    possible_errors = getsockname_errors(os, current, sockfd, address, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (\deref(addrlen) > socket_addrlen) {
        address->sun_family := AF_UNIX
        address->sun_path := socket.socket_address
    } else { // Buffer is too small
        truncate_address(address) 
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end



const POSSIBLE_SOCKET_TYPES : SockType-set-set // Множество корректных типов сокета {. SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET .} >< {. SOCK_NONBLOCK .} >< {. SOCK_CLOEXEC .}. Тип сокета (SOCK_STREAM, SOCK_DGRAM, SOCK_RDM etc), и (опционально) флаги SOCK_NONBLOCK или SOCK_CLOEXEC. Т.е. либо тройка, либо двойка, либо только тип сокета (SOCK_STREAM etc).
const MAX_FDS_PER_PROC : Nat // Максимальное число файловых дескрипторов для одного процесса
const MAX_OPEN_FILES   : Nat // Максимальное число открытых файлов в системе. Это число может быть найдено, например, в файле /proc/sys/fs/file-max



logical set_len
params
  T    @TYPE
  setP @IN : T-set
  res  @OUT: Nat
end
  attr text: Количество элементов в множестве {setP}



logical socket_errors // сокращение для получения множество вохможноых ошибок, при заданных входных данных для системного вызова socket.
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set // Почему-то SOCK_STREAM | SOCK_DGRAM в AF_UNIX успешно создает SOCK_DGRAM сокет...
    protocol  @IN  : Protocol
    errors    @OUT : Error-set
function

    return {. errcode for errcode : Error | (errcode == EACCES) && False || # EACCES не нашёл где возникает, кроме случая с андроид
    (errcode == EAFNOSUPPORT) && (domain != AF_UNIX) ||
    (errcode == EPROTONOSUPPORT) && (protocol != PF_UNIX && protocol != 0) || 
    (errcode == EINVAL) && (sock_type \notisin POSSIBLE_SOCKET_TYPES) || 
    (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
    (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
    (errcode == ENOBUFS) && False || # Не знаю как, поэтому не специфицирую
    (errcode == ENOMEM) && False ||  # Не знаю как, поэтому не специфицирую 
    (errcode == ESOCKTNOSUPPORT) && (sock_type \intersect {. SOCK_STREAM .} == {. .} || sock_type \intersect {. SOCK_DGRAM .} == {. .} && sock_type \intersect {. SOCK_SEQPACKET .} == {. .}) .}
end



logical bind_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : Sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    abs_path = make_path_abs(current, sockaddr->sun_path)
    
    return {. errcode for errcode : Error | (errcode == EACCES) && (abs_path(0) != '\0' && access_to_write(os, abs_path)) ||
        (errcode == EADDRINUSE) && (abs_path \isin \dom(os.os_socket_table)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINVAL) && (socket.socket_addrlen != 0 || addrlen != 'sizeof(struct sockaddr_un)') || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EADDRNOTAVAIL) && (False) || 
        (errcode == EFAULT) && (False) || #EFAULT addr points outside the user's accessible address space.
        (errcode == ELOOP) && (False) || # Todo
        (errcode == ENAMETOOLONG) && (addrlen >= PATH_MAX) || 
        (errcode == ENOENT) && ('Одной из директорий в пути для данного адреса не существует') || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTDIR) && ('В пути встречена не директория') || 
        (errcode == EROFS) && (False) .}
end


logical listen_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)

    # У unix socket eaddrinuse не возникает
    return {. errcode for errcode : Error | (errcode == EADDRINUSE) && (socket.socket_address \isin \dom(os.os_socket_table)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type == SOCK_DGRAM).}
end



logical connect_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat
    server   @IN  : Socket
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    
    return {. errcode for errcode : Error | (errcode == EACCES) && (socket.socket_address(0) != '\0' && access_to_write(os, socket.socket_address)) || 
        (errcode == EPERM) && (False) || 
        (errcode == EADDRINUSE) && (socket.socket_address \isin \dom(os.os_socket_table)) || 
        (errcode == EADDRNOTAVAIL) && (False) || 
        (errcode == EAFNOSUPPORT) && (sockaddr.sun_family != AF_UNIX) ||
        (errcode == EAGAIN) && (O_NONBLOCK \isin openfile.openfile_flags && is_free_space_in_backlog(server)) || 
        (errcode == EALREADY) && (False) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNREFUSED) && (server.socket_status != LISTEN) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EISCONN) && (socket.socket_status == CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EPROTOTYPE) && (socket.socket_type != server.socket_type) || 
        (errcode == ETIMEDOUT) && (False) .}
end


# TODO
#The receive queue is logically terminated if an end-of-file indication has been received or a connection has been terminated. A segment shall be considered to be terminated if another segment follows it in the queue, if the segment completes a record, or if an end-of-file or other connection termination has been reported. The last segment in the receive queue shall also be considered to be terminated while the socket has a pending error to be reported.


logical accept_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set    
function
#If address is not a null pointer, the address of the peer for the accepted connection shall be stored in the sockaddr structure pointed to by address, and the length of #this address shall be stored in the object pointed to by address_len.

#If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address shall be truncated.

    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EAGAIN) && (\not backlog_is_not_empty(socket)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNABORTED) && (False) || 
        (errcode == EFAULT) && (False) ||
        (errcode == EINVAL) && (\deref(addrlen) != 'sizeof(struct sockaddr_un)' || socket.socket_status != LISTEN) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type != SOCK_STREAM && socket.socket_type != SOCK_SEQPACKET) || 
        (errcode == EPROTO) && (False)
        q.}

end


logical close_errors
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Error-set
function
    #socket = get_sock_data(current, sockfd)
    #openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINTR) && (False) || 
        (errcode == EIO) && (False) || 
        (errcode == ENOSPC) && (False) || 
        (errcode == EDQUOT) && (False).}
end



logical shutdown_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Error-set
function
    #socket = get_sock_data(current, sockfd)
    #openfile = get_open_file(current, sqockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINVAL) && (how != SHUT_RD && how != SHUT_WR && how != SHUT_RDWR) || 
        (errcode == ENOTCONN) && (socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end



logical socketpair_errors
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol-set
    fds       @IN  : Nat -m-> Nat
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EAFNOSUPPORT) && (domain != AF_UNIX) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC - 1) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES - 1) ||
        (errcode == EOPNOTSUPP) && (protocol != PF_UNIX && protocol != PF_UNSPEC) || 
        (errcode == EPROTONOSUPPORT) && (protocol != PF_UNIX && protocol !+ PF_UNSPEC) .}
end


logical getpeername_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    address  @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (\deref(addrlen) != 'sizeof(sockaddr_un)') || 
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOTCONN) && (socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end



logical getsockname_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    address  @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set
function
    #socket = get_sock_data(current, sockfd)
    #openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (\deref(addrlen) != 'sizeof(sockaddr_un)') || 
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end



logical get_files_in_path
params
    os   @IN  : OS
    path @IN  : Text
    res  @OUT : File-list
function
    * Возвращает список файлов в заданном пути, в соотвествие с длинной пути т.е. res(0) - корень, res(1) = /home, res(2) = /home/username и т.д., последним элементом является сам файл.
end 



event access_to_write
params
    os      @IN  : OS
    path    @IN  : Text
    res     @OUT : Bool
function
    * Проверяет наличие x на всех директориях пути, и проверяет w на финальном файле
end
    attr algorithm: 'Алгоритм, проверяющий наличие доступа на запись, для файла'


#TODO -32 для размера сокета...


note 'OBJTREE_NOTE' is
@objtree[root:OS]@
endnote

endmodule

