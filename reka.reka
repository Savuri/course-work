# 3 перевода строки - разделение между объектами/событиями
# 1 перевода строки разделение между атрибутами
module 'Абстрактные модели'
  attr target_object: 'система'

import everything from types
import logicals from errors 


object OS is 
**OS** - объект, представляющий систему целиком
end

objattr os_open_file_table : OpenFile-set is
**os_open_file_table** - таблица открытых файлов ОС. В этой таблице происходит регистрация всех открытых в системе файлов.
end

objattr os_files : File-set is
**os_files** - множество всех файлов в файловой системе.
end

objattr os_proceses : Process-set is 
**Proos_procesescesses** - множество процессов в системе.
end

objattr os_socket_table : Text -m-> Socket is
**os_socket_table** - отображение адресса unix сокета (т.е. строки) в сокет с таким адресом.
end

objattr os_users : Uid-set is
**os_users** - множество всех пользователей, зарегистрированных в системе. (/etc/passwd)
end

objattr os_groups : Gid-set is
**os_groups** - множество всех пользователей, зарегистрированных в системе. (/etc/group)
end
endobject



object Process is
**Process** - отдельный процесс ОС.
end

objattr proc_pid : Int is
**proc_pid** - уникальный индефикатор процесса.
end

objattr proc_errno : Int is
**proc_errno** - атрибут, хранящий целочисленный код последней ошибки.
end

objattr proc_fds : Nat -m-> Fd is 
**proc_fds** - таблица открытых файловых дескрипторов процесса.
end

objattr proc_cred : Cred is
**proc_cred** - информация о правах процесса.
end

objattr proc_sigaction_array : Nat -m-> Sigaction is # sighand_struct === k_sigaction[_NSIG] === proc_sigaction_array
**proc_sigaction_array** - информация об обработчиках процесса. Отображение номера сигнала в # (обработку сигналов не прикручивал)
end

objattr proc_pending_signals : Nat-list is # Это более расширеная структура с информацией о том от кого пришло и т.д. т.е. с полем 'siginfo_t info';
**proc_pending_signals** - номера сигналов, пришедших на обработку. 
end

objattr proc_blocked_signals : Sigset is # Nat есть здесь, если сигнал блокируется. В реальности это битовая маска, но я пока сигналы их номером описываю.
**proc_blocked_signals** - в этом множестве находятся номера сигналов, которые блокируются.
end

objattr proc_status : ProcStatus is 
**proc_status** - текущее состояние процесса
end
endobject



object Fd is
**Fd** - файловый дескриптор.
end

objattr fd_open_file_ref : OpenFile-ref is 
**fd_open_file_ref** - ссылка на структуру с информацией об открытом файле.
end

objattr fd_flags : FdFlag-set is # Хотя возможен только один
**fd_flags** - флаги, которые приписаны к файловому дескриптору на уровне конкретного процесса.
end
endobject

object File is
**File** - объект, представляющий файл в ФС
end

objattr file_path : Text is
**file_path** - абсолютный путь до файла.
end

objattr file_type : FileType is
**file_type** - тип файла.
end

objattr file_cred : Fcred is
**file_cred** - Информация об обладателе и правах доступа
end
endobject



object OpenFile is 
**OpenFile** хранит информацию об открытом файле. Например, такие данные, как флаги доступа, оступ в файле и т.д..
end

# Бывший of_op_type - операции определённые для этого типа. Этим хотелось выразить наличия поля op в стркутуре откртытого файла, с целью различения типов открытых файлов. Здесь он просто равен типу файлу.
objattr of_type : FileType is
**of_type** - тип открытого файла. # Дублирует тип File. Дублирование необходимо т.к. файла для сокета в ФС ещё может не быть, но подсмотреть тип файла для описание ошибочных ситуаций нужно.  
end

objattr of_file : File-ref is
**of_file** - хранит ссылку на соотвестующий этому **OpenFile**, объект **File**.
end

objattr of_ref_cnt : Int is
**of_ref_cnt** - число ссылающихся на эту запись файловых дескрипторов.
end

objattr of_flags : OpenFileFlag-set is # Как-то не точно описано, но усложнять не хочется. (не точность в возможности присутствия одновременно O_RDONLY, и O_WRONLY, и O_RDWR, хотя в реальности возможно наличие только одного из них)  
**of_flags** - флаги открытого файла. 
end

objattr of_private_data : Socket-ref is
**of_private_data** - ссылка на важные структура данных. (Здесь находится ссылка на структуру сокет).
end
endobject



object Socket is 
**Socket** - объект представляющий собой UNIX сокет.
end

objattr socket_status : SocketStatus is
**socket_status** - текущий статус сокета
end

objattr socket_address : Text is
**socket_address** - адрес сокета.
end

objattr socket_addrlen : Nat is
**socket_addrlen** - длина адреса сокета.
end

objattr socket_queue : Socket-list is 
**socket_queue** - очередь для accept.
end

objattr socket_backlog : Int is
**socket_backlog** - длина очереди полностью настроенных сокетов, которые ждут принятия.
end

objattr socket_peer : Socket-ref is
**socket_peer** - ссылка на сокета-друга, с котором б общение.
end

objattr socket_flags : SocketFlags is
**socket_flags** - флаги сокета. Осуществлять управление этими флагами можно с помощью *setsockopt* и  *getsockopt*
end

objattr socket_type : SockType is
**socket_type** - тип сокета.
end

objattr socket_shutdown_flags : ShutdownFlags-set is
**socket_shutdown_flags** - флаги, обозначающие закрытие на операции чтения и записи, выполняемые этим сокетом. 
end

objattr socket_buf : sk_buff-list is
**socket_buf_list** - буффер сокета.
end

objattr socket_so_sndbuf : Nat is
**socket_so_buff** - размер буффера сокета. Значение, получаемое getsockopt() с SO_SNDBUF
end

objattr socket_used_buffer : Nat is
**socket_used_buffer** - уже использованный количество байт буффера.
end

objattr socket_cur_buffer_cnt : Nat is
**socket_cur_buffer_cnt** - количество уже выделенных буфферов.
end
endobject



const DEFAULT_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_default
const MAX_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_max


logical to_sockaddr_ref
params
    prm1 @IN  : void*
    ret  @OUT : Sockaddr_un-ref
function
    * Преобразует указатель в Sockaddr_un-ref
end



logical to_nat_ref
params
    prm1 @IN  : void*
    ret  @OUT : Nat-ref
function
    * Преобразует указатель в nat-ref
end



action add_to_list // Добавить элемент в список l (по стратегии fifo).
params
    T @TYPE
    l @IN : T-list
    el   @IN : T
function 
    l(\len l) := el
end



logical get_list_head // Взять первый элемент списка l с удалением.
params
    T    @TYPE
    l @IN  : T-list
    el   @OUT : T
function
    * Взять первый элемент списка l с удалением.
end



action del_from_list // Удалить элемент idx из списка l.
params
    T    @TYPE
    fifo @IN  : T-list
    idx  @IN  : Nat
function
    * Удалить элемент idx из списка l.
end



action add_to_set
params
  T     @TYPE
  set1  @IN    : T-set
  el    @IN    : T
function
  set1 := set1 ∪ {. el .} // !Добавить el в set1
end



action remove_from_set
params
  T    @TYPE
  set1 @IN   : T-set
  el   @IN   : T
function
  set1 := set1 \diff el
end 


# Для сокращения записи
action get_sock_data // получить структуру данных для процесса current и сокета sockfd.
params
    current @IN  : Process
    sockfd  @IN  : Nat
    sock    @OUT : Socket
function
    sock = current.proc_fds(sockfd).fd_open_file_ref.of_private_data 
end


# Для сокращения
action get_by_address
params
    os        @IN  : OS
    sock_addr @IN  : Text
    sock      @OUT : Socket
function 
    sock = os.os_socket_table(sock_addr)
end



# Для сокращения записи
action get_open_file // получить открытый файл для процесс current и сокета fd.
params
    current @IN  : Process
    fd      @IN  : Nat
    of      @OUT : OpenFile
function
    of = \deref current.proc_fds(fd).fd_open_file_ref
end

action add_to_map
params
  T1    @TYPE
  T2    @TYPE
  map   @IN    : T1 -m-> T2
  key   @IN    : T1
  el    @IN    : T2
function
    map(key) := el // !Добавить el в map с ключом key
end



action remove_from_map
params
  T1  @TYPE
  T2  @TYPE
  map @IN : T1 -m-> T2
  key @IN : T1
function
    * Удалить элемент key из map
end


const NULL : void*
const Nothing // Константа для неинициализированных частей

event socket // socket
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fd        @OUT : Int
invariant domain == AF_UNIX // Модель только для UNIX сокетов
invariant current \isin os.os_proceses // Текущей процесс существует в рамках системы
function
    possible_errors = socket_errors(os, current, domain, sock_type, protocol)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    forany(newFD : Nat | newFD \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD) => nn \isin \dom(current.proc_fds)) {
    socket = 'mk_socket(.socket_status=UNCONNECTED, .socket_address=Nothing, .socket_addrlen=Nothing, .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(), socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
        
        if (SOCK_DGRAM \isin sock_type) {
            socket.socket_type := SOCK_DGRAM
        } elif (SOCK_STREAM \isin sock_type) {
            socket.socket_type := SOCK_STREAM
        } else { //SOCK_SEQPACKET \isin sock_type
           socket.socket_type := SOCK_SEQPACKET
        }
        
        openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket)'    
            
        if (SOCK_NONBLOCK \isin sock_type) {
            add_to_set(openfile.of_flags, O_NONBLOCK)
        }
        
        if (SOCK_CLOEXEC \isin sock_type) {
            newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. FD_CLOEXEC .})'
        } else {
            newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'
        }
        
        add_to_map(current.proc_fds, newFD, newFDObject)
        add_to_set(os.os_open_file_table, openfile)
            
        return newFD
    }
end



const PATH_MAX : Nat // Maximum path size in system


# TODO описать алгоритм. Как я понимаю по итогу это нужно будет описывать с помощью алгоритма.
logical make_path_abs // если сокет абстрактный, то возвращаем путь. Если путь абсолютный, то избавляемся от ., .., символьных ссылок в пути. Если путь относительный, добавляем слева current_cur_path и избавляемся от ., .., символьных ссылок в пути.
params
    current @IN  : Process
    path    @IN  : Text
    abs     @OUT : Text
function
    if (path(0) == '\0') {
        return path
    }
    
    * Если путь абсолютный, то избавляемся от ., .., символьных ссылок в пути. Если путь относительный, добавляем слева current_cur_path и избавляемся от ., .., символьных ссылок в пути.
end



event bind // bind
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int
function
    get_sock_data(current, sockfd, socket)
    get_open_file(current, sockfd, openfile)

    sock_address = make_path_abs(current, \deref(sockaddr).sun_path)

    if (sock_address(0) != '\0') { # Обычный сокет. Абстрактному сокету это не нужно.
        newFile = 'mk_File(.file_path=sock_address, .file_type=SOCKET_TYPE, .file_cred = { fc_uid, .fc_gid, .fc_permissions = {. S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH.} \diff current.proc_cred.cr_umask })' // Создание нового файла
        add_to_set(os.os_files, newFile) // Добавление файла в ФС
        openfile.of_file := newFile // сокет связывается с созданным файлом
        #TODO: user, group, permission... в errors?
    }
    
    socket.socket_address := sock_address
    socket.socket_addrlen := addrlen
    add_to_map(os.os_socket_table, sock_address, socket) // зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
    
    return 0
end



const SOMAXCONN : Nat // значение в /proc/sys/net/core/somaxconn файле



event listen // listen
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Int
function
    get_sock_data(current, sockfd, socket)

    if (backlog > SOMAXCONN) {
        socket.socket_backlog := SOMAXCONN
    } else {
        socket.socket_backlog := backlog
    }
    
    socket.socket_status := LISTEN
        
    return 0
end



logical is_free_space_in_backlog
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появилось место для постановки себя в очередь на подключение (\len(server.socket_queue) < server.socket_backlog)



logical was_accepted
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    socket     @IN  : Socket
    res        @OUT : Bool 
end
    attr event-desc: Запрос на подключение был принят сервером. (socket \notisin server.socket_queue).

event connect // systemcall connect
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int 
function
    #Комментарий из кода -> Фича Linux: If possible we block in connect(2) if the max backlog of the listen socket is been reached. This won't break old apps and it will avoid huge amount of socks hashed (this for unix_gc() performances reasons).
    get_sock_data(current, sockfd, socket)
    get_by_address(os, \deref(sockaddr).sun_path, server)

    if (socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) {
        socket.socket_status := CONNECTING
        
        current.proc_status := S
        
       
        wait INFWAIT {
            trigger (is_free_space_in_backlog(server)) { // текст для триггера 1
                current.proc_status := R
                add_to_list(server.socket_queue, socket) 
            }
            
            trigger (interrupt_logical(current, socket)) { // текст для триггера 2
                current.proc_errno := EINTR
                current.proc_status := R
                return -1
            }
        }
        
        current.proc_status := S
        
        wait INFWAIT {
            trigger (was_accepted(server, socket)) { // текст для триггера 1
                #socket.socket_status := CONNECTED -- устанавливает это сервер (в accept)
                #socket.socket_peer := -- устанавливает это сервер.
                del_from_list(server.socket_queue, 0)
                current.proc_status := R
            }
                
            trigger (interrupt_logical(current, socket)) { // текст для триггера 2
                # Описать подчищивание надо? я про верхний wait. TODO(??)
                current.proc_errno := EINTR
                current.proc_status := R
                return -1
            }
        }
    } else {
        socket.socket_peer := server
        socket.socket_status := CONNECTED
    }
    
    return 0    
end



logical backlog_is_not_empty
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появился запрос на подключение (server.socket_queue != <..>)



#TODO accept4. Хорошо что оно к accept сводится
#On Linux, the new socket returned by accept() does not inherit file status flags such as O_NONBLOCK and O_ASYNC from the listening socket. В POSIX об этом ничего нет.
event accept // accept
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat-ref
    ret      @OUT : Int
function
    get_sock_data(current, sockfd, socket)
   
    current.proc_status := S
    wait INFWAIT { 
        trigger (backlog_is_not_empty(socket)) { // текст для триггера 1. Есть кого принимать
            current.proc_status := R
            peer = get_list_head(socket.socket_queue) // Тот, кто подсоединяется
            forany(newFD : Nat | newFD \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD) => nn \isin \dom(current.proc_fds)) { // Создаются fd, OpenFile, Socket. Причём все поля у новых OpenFile и Socket такие же, как и у этих же объектов соотвестующих sockfd. 
                forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && newUnixAddress(0) == '\0') {
                    new_socket = 'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress, .socket_addrlen=\len(newUnixAddress), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=peer, .socket_flags={. .}, .socket_type=socket.socket_type, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=socket.socket_so_sndbuf, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                
                    peer.socket_peer := new_socket
                    peer.socket_status := CONNECTED
                    
                    if (sockaddr != to_sockaddr_ref(NULL)) { //sockaddr != NULL
                        * strncmp(\ref(\deref(sockaddr).sun_path), \ref(newUnixAddress), min(\len(newUnixAddress, \deref(addrlen)))
                        \deref(addrlen) := \len(newUnixAddress)      
                    }

                    openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, of_flags={. O_RDWR .}, .of_private_data=socket)'    
                    newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'

                    add_to_map(current.proc_fds, newFD, newFDObject)
                    add_to_set(os.os_open_file_table, openfile)
                    add_to_map(os.os_socket_table, new_socket.socket_address.sun_path, new_socket)
                
                    return newFD   
                }
            } 
        }
            
        trigger (interrupt_logical(current, socket)) { // текст для триггера 22
            current.proc_errno := EINTR
            current.proc_status := R
            return -1   
        }
    }
end


#TODO
event close // close (описывался к применнию только для fd сокета)
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Int
invariant current.proc_fds(fd).fd_open_file_ref.of_ref_cnt >= 1// Если у файла ref_cnt == 0, то его в этой таблице быть не должно 
invariant current.proc_fds(fd).fd_open_file_ref.of_type == SOCKET_TYPE// Вызов рассматривается только для сокетов
function
    get_sock_data(current, fd, socket)
    get_open_file(current, fd, open_file)

    remove_from_map(current.proc_fds, fd)
    open_file.of_ref_cnt--
 
    if (open_file.of_ref_cnt == 0) {
        remove_from_set(os.os_open_file_table, \deref(open_file))
        remove_from_map(os.os_socket_table, socket.socket_address)
    }
    
    return 0
end



event shutdown // shutdown
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Int
function
    get_sock_data(current, sockfd, socket)
    peer = socket.socket_peer

    if (how == SHUT_RD) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)  
    } elif (how == SHUT_WR) {
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    } elif (how == SHUT_RDWR) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    }
    
    return 0    
end



event socketpair // socketpair
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol-set
    fds       @IN  : Nat -m-> Nat
    fd        @OUT : Int
function
    forany(newFD1 : Nat | newFD1 \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD1) => nn \isin \dom(current.proc_fds)) {
        forany(newFD2 : Nat | newFD2 \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD2) => nn \isin \dom(current.proc_fds)) {
            forany(newUnixAddress1 : Text | newUnixAddress1 \notisin \dom(os.os_socket_table) && newUnixAddress1(0) == '\0') {
                forany(newUnixAddress2 : Text | newUnixAddress2 \notisin \dom(os.os_socket_table) && newUnixAddress2(0) == '\0') {
                    socket1 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress1, .socket_addrlen=\len(newUnixAddress1), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                    socket2 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress2, .socket_addrlen=\len(newUnixAddress2), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                    socket1.socket_peer := socket2
                    socket2.socket_peer := socket1
                    
                    if (SOCK_DGRAM \isin sock_type) {
                        socket1.socket_type := SOCK_DGRAM
                        socket2.socket_type := SOCK_DGRAM
                    } elif (SOCK_STREAM \isin sock_type) {
                        socket1.socket_type := SOCK_STREAM
                        socket2.socket_type := SOCK_STREAM
                    } else { //SOCK_SEQPACKET \isin sock_type
                        socket1.socket_type := SOCK_SEQPACKET
                        socket2.socket_type := SOCK_SEQPACKET
                    }
                    
                    openfile1 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket1)'
                    openfile2 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket2)'    
                        
                    if (SOCK_NONBLOCK \isin sock_type) {
                        add_to_set(openfile1.of_flags, O_NONBLOCK)
                        add_to_set(openfile2.of_flags, O_NONBLOCK)
                    }
                    
                    if (SOCK_CLOEXEC \isin sock_type) {
                        newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. FD_CLOEXEC .})'
                        newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. FD_CLOEXEC .})'
                    } else {
                        newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. .})'
                        newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. .})'
                    }
                    
                    add_to_map(current.proc_fds, newFD1, newFDObject1)
                    add_to_map(current.proc_fds, newFD2, newFDObject2)
                    add_to_set(os.os_open_file_table, openfile1)
                    add_to_set(os.os_open_file_table, openfile2)
                    add_to_map(os.os_socket_table, newUnixAddress1, socket1)
                    add_to_map(os.os_socket_table, newUnixAddress2, socket2)

                    fds(0) := newFD1
                    fds(1) := newFD2
                    
                    return 0
                }
            }
        }
    }

end

############## IO part start ###########
#TODO нормальное завршение. Доьавить артрибут сокеты на состояние tcp соединения, который будет меняться в close. Отразить в recvmsg_generic/sendmsg_generic реакцию на закрытии другой стороны соединения + добавить что если tcp close то переназначить нельзя(?)

#TODO
event getsockopt
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    level   @IN  : Level
    optname @IN  : SocketFlag
    optval  @IN  : void*
    optlen  @IN  : Nat-ref
    ret     @OUT : Int
function
    if (optname == SO_ACCEPTCONN) {
    } elif (optname == SO_ATTACH_FILTER) {
    } elif (optname == SO_ATTACH_BPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
    } elif (optname == SO_BINDTODEVICE) {
    } elif (optname == SO_BROADCAST) {
    } elif (optname == SO_BSDCOMPAT) {
    } elif (optname == SO_DEBUG) {
    } elif (optname == SO_DETACH_FILTER) {
    } elif (optname == SO_DETACH_BPF) {
    } elif (optname == SO_DOMAIN) {
    } elif (optname == SO_ERROR) {
    } elif (optname == SO_DONTROUTE) {
    } elif (optname == SO_INCOMING_CPU) {
    } elif (optname == SO_KEEPALIVE) {
    } elif (optname == SO_LINGER) {
    } elif (optname == SO_LOCK_FILTER) {
    } elif (optname == SO_MARK) {
    } elif (optname == SO_OOBINLINE) {
    } elif (optname == SO_PASSCRED) {
    } elif (optname == SO_PASSSEC) {
    } elif (optname == SO_PEEK_OFF) {
    } elif (optname == SO_PEERCRED) {
    } elif (optname == SO_PRIORITY) {
    } elif (optname == SO_PROTOCOL) {
    } elif (optname == SO_RCVBUF) {
    } elif (optname == SO_RCVBUFFORCE) {
    } elif (optname == SO_RCVLOWAT) {
    } elif (optname == SO_SNDLOWAT) {
    } elif (optname == SO_RCVTIMEO) {
    } elif (optname == SO_SNDTIMEO) {
    } elif (optname == SO_REUSEADDR) {
    } elif (optname == SO_REUSEPORT) {
    } elif (optname == SO_RXQ_OVFL) {
    } elif (optname == SO_SNDBUF) {
    } elif (optname == SO_SNDBUFFORCE) {
    } elif (optname == SO_TIMESTAMP) {
    } elif (optname == SO_TIMESTAMPNS) {
    } elif (optname == SO_TYPE) {
    } elif (optname == SO_BUSY_POLL) {
    } elif (optname == SO_TIMESTAMPING) {
    }
    
    return 0
end


#TODO
event setsockopt
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    level   @IN  : Level
    optname @IN  : SocketFlag
    optval  @IN  : void*
    optlen  @IN  : Nat
    ret     @OUT : Int
function
    #if (optname == SO_ACCEPTCONN) - не settable
    if (optname == SO_ATTACH_FILTER) {
    } elif (optname == SO_ATTACH_BPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
    } elif (optname == SO_BINDTODEVICE) {
    } elif (optname == SO_BROADCAST) {
    } elif (optname == SO_BSDCOMPAT) {
    } elif (optname == SO_DEBUG) {
    } elif (optname == SO_DETACH_FILTER) {
    } elif (optname == SO_DETACH_BPF) {
    } elif (optname == SO_DOMAIN) {
    } elif (optname == SO_ERROR) {
    } elif (optname == SO_DONTROUTE) {
    } elif (optname == SO_INCOMING_CPU) {
    } elif (optname == SO_KEEPALIVE) {
    } elif (optname == SO_LINGER) {
    } elif (optname == SO_LOCK_FILTER) {
    } elif (optname == SO_MARK) {
    } elif (optname == SO_OOBINLINE) {
    } elif (optname == SO_PASSCRED) {
    } elif (optname == SO_PASSSEC) {
    } elif (optname == SO_PEEK_OFF) {
    } elif (optname == SO_PEERCRED) {
    } elif (optname == SO_PRIORITY) {
    } elif (optname == SO_PROTOCOL) {
    } elif (optname == SO_RCVBUF) {
    } elif (optname == SO_RCVBUFFORCE) {
    } elif (optname == SO_RCVLOWAT) {
    } elif (optname == SO_SNDLOWAT) {
    } elif (optname == SO_RCVTIMEO) {
    } elif (optname == SO_SNDTIMEO) {
    } elif (optname == SO_REUSEADDR) {
    } elif (optname == SO_REUSEPORT) {
    } elif (optname == SO_RXQ_OVFL) {
    } elif (optname == SO_SNDBUF) {
    } elif (optname == SO_SNDBUFFORCE) {
    } elif (optname == SO_TIMESTAMP) {
    } elif (optname == SO_TIMESTAMPNS) {
    } elif (optname == SO_TYPE) {
    } elif (optname == SO_BUSY_POLL) {
    } elif (optname == SO_TIMESTAMPING) {
    }
    
    
    return 0
end



logical interrupt_logical
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    current    @IN  : Process 
    socket     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Прерывание ожидания процесса, из-за прихода сигнала, который не блокируется маской (current.proc_pending_signals != <..> && exists x:Nat | (x \isin current.proc_pending_signals) && (x \notisin curren.proc_blocked_signals)). Если для пришедшего сигнала верно SA_RESTART \isin current.proc_sigaction_array(signum).signal_flags && SO_RCVTIMEO \notisin socket.socket_flags это эквиваленто перезапуску системного вызова т.е. в этом случае res == False, иначе res == True. 



logical max_msg_cnt # Я не знаю как это получить. Оно зависит от SO_SNDBUF текущего сокета => Параметр - сокет-отправитель
params
    sock @IN  : Socket
    ret  @OUT : Nat
function
    // Как-то связано с so_sndbuf. Как это посчитать не знаю
end



event get_msg_len
params
    msg @IN  : msghdr
    res @OUT : Nat
function
    def _res : Nat := 0

    for (i in [0..msg.msg_iovlen]) {
        _res := _res + msg.msg_iov(i).iov_len
    }
    
    return _res
end
    attr algorithm: 'Алгоритм, считающий размер данных в msg'



#TODO: убрать memcpy
event load_data
params
    msg     @IN  : msghdr
    sender  @IN  : Socket
    reciver @IN  : Socket
function
    buf = 'mk_skbuff(".buf_data = alloc_ptr(), .data_len = 0, .consumed = 0, buf_control_data = alloc_prt(), control_len = 0", .sender = sender.socket_address)' // Устанавливается адрес отправителя
    sender.socket_used_buffer := sender.socket_used_buffer + get_msg_len(msg) //(Отмечается изменение использованного пространства буффера данного сокета)
    sender.socket_cur_buffer_cnt++
    
    for (i in [0..msg.msg_iovlen]) {
        // Данные просматриваются последовательно и загружаются подряд
        * memcpy(buf.buf_data + buf.data_len, msg.msg_iov(i).iovbase, msg.msg_iov(i).iov_len) # Описываю будто адрессная арифметика с void* работает 1 байт
        // Устанавливается общий размер данных (поле data_len)
        buf.data_len := buf.data_len + msg.msg_iov(i).iov_len
    }
    
    if (msg.msg_controllen != 0) {
        //Если есть дополнительные данные, они загружаются
        * memcpy(buf.buf_control_data, msg.msg_control, msg.msg_controllen)
        // Устанавливается размер дополнительных данных  
        buf.control_len := msg.msg_controllen
    } else {
        // Если их нет, то буффер == null
        buf.buf_control_data := NULL
        //Устанавливается размер дополнительных данных
        buf.control_len := 0
    }
    
    add_to_list(reciver.socket_buf, buf)

end
    attr algorithm: 'Алгоритм загрузки данных'



logical is_possible_to_load_data
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    sender     @IN  : Socket
    reciver    @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Ждём освобождение места в буффера отправителя. (sender.socket_cur_buffer_cnt < max_msg_cnt(sender) || get_msg_len(msg) < socket.socket_so_sndbuf / 2 - socket.socket_used_buffer)



action sendmsg_generic // sendmsg_generic
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    get_sock_data(current, sockfd, socket)
    get_by_address(os, msg.msg_name, other)

    current.proc_status := S
    wait INFWAIT {
        trigger (is_possible_to_load_data(socket, other)) {//сообщение для тригерра 1
            current.proc_status := R
            load_data(msg, socket, other)
        }
            
        trigger (interrupt_logical(current, socket)) { // сообщение для триггера 2
            current.proc_errno := EINTR
            current.proc_status := R
            return -1   
        }
    }
    
    
    socket.socket_peer := other
    return 0
end


#If a blocked call to one of the following interfaces is
#interrupted by a signal handler, then the call is automatically
#restarted after the signal handler returns if the SA_RESTART flag
#was used; otherwise the call fails with the error EINTR:

#read, write, Socket interfaces: accept(2), connect(2), recv(2), recvfrom(2),
#recvmmsg(2), recvmsg(2), send(2), sendto(2), and sendmsg(2),
#unless a timeout has been set on the socket (see below).

#The following interfaces are never restarted after being
#interrupted by a signal handler, regardless of the use of
#SA_RESTART; they always fail with the error EINTR when
#interrupted by a signal handler:

#* "Input" socket interfaces, when a timeout (SO_RCVTIMEO) has
#been set on the socket using setsockopt(2): accept(2), recv(2),
#recvfrom(2), recvmmsg(2) (also with a non-NULL timeout
#argument), and recvmsg(2).

#"Output" socket interfaces, when a timeout (SO_RCVTIMEO) has
#been set on the socket using setsockopt(2): connect(2),
#send(2), sendto(2), and sendmsg(2).



#For datagram-oriented Unix Domain Socket, setting the SO_SNDBUF socket option has an effect, but the SO_RCVBUF option does not (manpage unix(7)). And even the buffer is big enough, we can still experience the packet overflow problem. That is because there is another limitation in the datagram type Unix Domain Socket. The backlog of the packets in the buffer is not unlimited. For example, the default value of the maximum backlog in most Linux systems is set to 10, i.e. only 10 packets can wait in the queue. The commands to check and increase the backlog limit are:
#        cat /proc/sys/net/unix/max_dgram_qlen
#        sysctl -w net.unix.max_dgram_qlen=128 
# У меня на машине тоже 10. Но в cat /proc/sys/net/unix/max_dgram_qlen не 10. Я не понимаю как это работает...
#fs.mqueue.msg_default. Нашёл


event sendmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr-ref
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function 
    sendmsg_generic(os, current, sockfd, \deref(msg), flags)
end

event sendto //sendto
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags-set
    dst      @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int    
function
    msg = 'mk_msg(.msg_name = \deref(dst).address, .msg_name_len = addrlen, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    sendmsg_generic(os, current, sockfd, msg, flags)
end



event send // send
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    get_sock_data(current, sockfd, socket123) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    sendmsg_generic(os, current, sockfd, msg, flags)
end



event write // write
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void* # void *buf
    count   @IN  : Nat
    ret     @OUT : Int
function
    get_sock_data(current, sockfd, socket123) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(msg_name = socket123.socket_peer.socket_address, msg_name_len = socket123.socket_peer.socket_address_len, ioveclist = &{buf, count}, msg_control = 0, msg_controllen = 0, msg_flags = 0)'
    
    sendmsg_generic(os, current, sockfd, msg, \emptyset)
end

#seqpacket в io ~ dgram
event min
params
    lhs @IN  : Int
    rhs @IN  : Int
    res @OUT : Int
function
    if (lhs < rhs) {
        return lhs
    } else {
        return rhs
    }
end
    attr algorithm: 'Алгоритм получения минимального среди двух Int.'


#TODO доделать (get_by_address в алгоритме не работает) + memcpy
event get_data
params
    os      @IN  : OS
    reciver @IN  : Socket
    msg     @IN  : msghdr-ref
    ret     @OUT : Nat
function
    def copied : Nat := 0
    def i : Nat := 0
    def iov : iovec

    if (reciver.socket_type == SOCK_DGRAM || reciver.socket_type == SOCK_SEQPACKET) {
        # Копируется первый пришедший буффер
        # Первый пришедший буффер копируется в msg.msg_iov, последовательно заполняя буфееры в msg.msg_iov. Если буфер больше суммарной длинные iov, то оставшиеся данные в буффере игнорируются
        # Если в первом буффере есть дополнительные данные, они копируются, с установлением их длинны
        # Этот буффер удаляется из socket.socket_buf
        # Отмечается освожодение памяти для отправителя после считывания буффера
        # Возвращает число считанных данных
        # в msg.msg_name загружается адрес отправителя (если изначального буффера не хватает, msg_name зануляется и устанавливается кореектный размер в msg.msg_namelen
        # в msg.msg_namelen длина адреса отправителя

        
        buf = reciver.socket_buf(0) // Первая пришедшая датаграмма
        'get_by_address(os, buf.sender, sender)' // Отправитель

        while ('i < \deref(msg).msg_iovlen && buf.consumed < buf.data_len') { #TODO while с двумя условиями
            iov := \deref(msg).msg_iov(i)
            cur_dgram_copied = min(iov.iov_len,  buf.data_len - buf.consumed)
            
            * copied := copied + memcpy(iov.iov_base, buf.buf_data + buf.consumed, cur_dgram_copied)
            
            buf.consumed := buf.consumed + cur_dgram_copied
            
            if (cur_dgram_copied == iov.iov_len) {
                i++
            }
        }
        
        if (buf.control_len != 0) {
            //Если есть дополнительные данные, они загружаются
            * memcpy(\ref(\deref(msg).msg_control), \ref(buf.buf_control_data), min(msg.msg_controllen, buf.control_len))
            // Устанавливается размер дополнительных данных  
            \deref(msg).msg_controllen := min(\deref(msg).msg_controllen, buf.control_len)
        } else {
            // Если их нет, то буффер == null
            \deref(msg).msg_control := NULL
            //Устанавливается размер дополнительных данных
            \deref(msg).msg_controllen := 0
        }
        
        'sender.socket_used_buffer := sender.socket_used_buffer - buf.data_len' // Освобождается память в буффере отправителя для последующих сообщений.
        'sender.socket_cur_buffer_cnt--'
        del_from_list(reciver.socket_buf, 0) // Прочитанная датаграмма удаляется.
        
        return copied
    } else {// recvier.socket_type == SOCK_STREAM
        # Всё, что ниже соотвствует следушющему текстовому описанию:
        # Просматриваются буфферы. Они там в порядке прихода сообщения. Просматриваются до тех пор, пока в сообщении не все буферы заполнены и пока буфферы для считывания есть и пока не встречен буффер с дополнительными данными (если буффер с дополнительными данными присутсвует, то копируются данные и дополнительные данные, устанавливается размер дополнительных данных (в случае чего обрезаются), буфер удаляется и чтение прекращается)
        # Данные из буфферов копируются в msg.msg_iov, последовательно заполняя буфееры в msg.msg_iov
        # Прочитанные полностью буфферы удаляются из socket.socket_buf. Степень прочитанности буффера - sk_buff.consumed
        # Отмечается освожодение памяти для отправителя после считывания буффера
        # Возвращает число считанных данных
        # в msg.msg_name загружается адрес отправителя (если изначального буффера не хватает, msg_name зануляется и устанавливается кореектный размер в msg.msg_namelen
        # в msg.msg_namelen длина адреса отправителя
        
        def cur_iov_base_size : Nat := 0 # cur_len of current iov
        
        while ('i < \deref(msg).msg_iovlen && socket.socket_buf != <. .>') {
            buf = reciver.socket_buf(0)
            
            
            def cur_stream_copied : Nat := 0
            # copy one socket buff
            while ('i < \deref(msg).msg_iovlen && buf.consumed < buf.data_len') {
                iov := \deref(msg).msg_iov(i)
            
                bytes_to_copy = min(iov.iov_len - cur_iov_base_size, buf.data_len - buf.consumed)
                
                cur_stream_copied := cur_stream_copied + bytes_to_copy
                
                # Предполагаю, что адресная арифметика для void* (т.е. iov.iov_base) байтова (void *) + 1 - сдвиг адреса на единицу
                * cur_iov_base_size := cur_iov_base_size + memcpy(iov.iov_base + cur_iov_base_size, buf.buf_data + buf.consumed, bytes_to_copy)
                buf.consumed := buf.consumed + bytes_to_copy
            
                if (cur_iov_base_size == iov.iov_len) {
                    cur_iov_base_size := 0
                    i++
                }
            }
            
            copied := copied + cur_stream_copied
            cur_stream_copied := 0
            
            if (buf.buf_control_data != NULL) { // Если есть дополнительные данные
                // Копируются дополнительный данные
                * memcpy(\ref(\deref(msg).msg_control), \ref(buf.buf_control_data), min(msg.msg_controllen, buf.control_len))
                msg.msg_controllen := buf.control_len
                
                // Освобождаются ресурсы
                'get_by_address(os, buf.sender, other)'
                'other.socket_used_buffer := other.socket_used_buffer - buf.data_len'
                'other.socket_cur_buffer_cnt--'
                del_from_list(socket_buf, 0)
                
                //Заверешение иттерации
                return copied  
            } elif (buf.consumed == buf.data_len) {
                'get_by_address(os, buf.sender, other)'
                'other.socket_used_buffer := other.socket_used_buffer - buf.data_len'
                'other.socket_cur_buffer_cnt--'
                del_from_list(socket_buf, 0)
            }
        }
        
        return copied     
   }
end
    attr algorithm: 'Алгоритм получения данных.'



logical msg_have_come
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
end
    attr event-desc: Появилось сообщения для считывания в буффере. (server.socket_buf != <. .>))



action recvmsg_generic
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr
    flags    @IN  : MsgFlags-set
    src      @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat-ref
function
    get_sock_data(current, sockfd, socket)
    
    current.proc_status := S
    wait INFWAIT {
        trigger (msg_have_come(socket)) { // Описание триггера 1
            current.proc_status := R
            res = get_data(os, socket, \ref(msg))
            
            if (src != to_sockaddr_ref(NULL) && addrlen != to_nat_ref(NULL)) {
                \deref(src)     := msg.msg_name
                \deref(addrlen) := msg.msg_namelen
            }
            
            return res
        }
        
        trigger (interrupt_logical(current, socket)) { // Описание триггера для прерываний
            current.proc_errno := EINTR
            current.proc_status := R
            return -1   
        }
    }
end



event recvmsg //recvmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr-ref
    flags    @IN  : MsgFlags-set
    ret      @OUT : Int
function
    recvmsg_generic(os, current, sockfd, \deref(msg), flags, to_sockaddr_ref(NULL), to_nat_ref(NULL))
end


event recvfrom //recvfrom
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : Nat-set
    src      @IN  : Sockaddr_un-ref
    addrlen  @IN  : Nat-ref
    ret      @OUT : Int  
function
    msg = 'mk_msg(.msg_name = \deref(src).address, .msg_name_len = addrlen, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    recvmsg_generic(os, current, sockfd, msg, flags, src, addrlen)
end


event recv // recv
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : Nat-set
    ret      @OUT : Int  
function
    get_sock_data(current, sockfd, socket123)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = Nothing, .msg_controllen = 0, .msg_flags = 0)'
    
    recvmsg_generic(os, current, sockfd, msg, flags, to_sockaddr_ref(NULL), to_nat_ref(NULL))
end



event read // read
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void*
    count   @IN  : Nat  
    ret     @OUT : Int
function
    get_sock_data(current, sockfd, socket123)
    
msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = 0)'
    
    recvmsg_generic(os, current, sockfd, msg, \emptyset, to_sockaddr_ref(NULL), to_nat_ref(NULL))
end



event getpeername
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : Sockaddr_un-ref
    addrlen @IN  : Nat-ref
    ret     @OUT : Int
function
    get_sock_data(current, sockfd, socket)

    if (\deref(addrlen) > socket.socket_addrlen) {
        \deref(address).sun_family := AF_UNIX
        \deref(address).sun_path := socket.socket_peer.socket_address
    } else { // Buffer is too small
        \deref(address) := 0 // Truncate address 
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end



event getsockname
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : Sockaddr_un-ref
    addrlen @IN  : Nat-ref
    ret     @OUT : Int
function
    get_sock_data(current, sockfd, socket)

    if (\deref(addrlen) > socket_addrlen) {
        \deref(address).sun_family := AF_UNIX
        \deref(address) := socket.socket_address
    } else { // Buffer is too small
        \deref(address) := 0 // Truncate address        
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end

#TODO: Autobind feature

note 'OBJTREE_NOTE' is
@objtree[root:OS]@
endnote

endmodule

