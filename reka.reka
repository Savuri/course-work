# 1 перевода строки внутри объекта
module 'Абстрактные модели'
  attr target_object: 'система'

#import everything from types
#import logicals from errors 
#Types#

type Uid : Nat // численный индефикатор пользователя
type Gid : Nat // численный индефикатор группы

type Gids : Gid-set
type Uids : Uid-set


type Permission:
enum
    S_IRUSR                       
    S_IWUSR                        
    S_IXUSR                   
    S_IRGRP
    S_IWGRP
    S_IXGRP
    S_IROTH
    S_IWOTH
    S_IXOTH
endtype


type Permissions : Permission-set


type Cred : struct
{
    Uid cr_uid;            // Real user id
    Uid cr_euid;           // Effective user id
    Uid cr_suid;           // saved effective user id.
    Gid cr_gid;            // Real group id 
    Gid cr_egid;           // effective group id
    Gid cr_sgid;           // Saved effective group id
    Int cr_ngroups;       // number of groups
    Gids cr_groups;     // groups
    Permissions cr_umask;    // umask
}
is
**Cred** - структура, хранящая информацию о правах процесса
endtype



type Fcred : struct
{
    Uid fc_uid;
    Gid fc_gid;
    Permissions fc_permission;
}
endtype

# Раздел сигналов - Beg
#type Handler  -- не нужно
#type Handler3 -- не нужно
type Sigset : Nat-set
type SignalFlag: # Мне достаточно описать SA_RESTART
enum
    SA_RESTART // Перезапустить определённый системный вызов.
endtype
type SignalFlags : SignalFlag-set

type Sigaction : struct
{
    #Handler hand; // Обработчик с одним параметром.
    #Handler3 sigact; // Обработчик с 3мя параметрами.
    SignalFlags signal_flags; // Флаги сигналов.
    #Sigset sigset; // contains a bitmask with exactly one bit for each signal available in the system. It is used to block other signals during execution of the handler routine. Мне это не нужно.
}
is
**Sigaction** - структура, описывающая работу с сигналами. 
endtype
# Раздел сигналов - End

type ProcStatus:
enum
    R // running or runnable (on run queue)
    S // interruptible sleep (waiting for an event to complete) (В этом состоянии процесc при блокировке)
is
**ProcStatus** - перечислимый тип, содержащий статус текущего процесса:
$enumdefs$
endtype

type FdFlag: 
enum
    FD_CLOEXEC // close on exec
is
**FdFlag** - тип для флагов, которые приписаны к файловому дескриптору на уровне конкретного процесса:
$enumdefs$
endtype

type FileType:
enum
    REGULAR_FILE_TYPE // обычный файл
    DIRECTORY_TYPE    // директория
    SOCKET_TYPE       // сокет
is
**FileType** - перечислимы тип, описывающий типы файлов:
$enumdefs$
endtype

type OpenFileFlag :
enum
    O_RDONLY  // доступ на чтение
    O_WRONLY  // доступ на запись
    O_RDWR    // доступ и на чтение, и на запись
    O_NONBLOCK  // запрет блокировки
is
**OpenFileType** перечисление флагов открытых файлов:
$enumdefs$
endtype



type OpenFileRefArray : OpenFile-ref-list


type sk_buff : struct 
{
    void* buf_data; // буффер в котором передаются данные
    Nat data_len; // количество байт данных
    Nat consumed; // количество прочитанных байт данных (Нужно для SOCK_STREAM).
    void* buf_control_data; // буффер дополнительных данных
    Nat control_len; // количетсво байт дополнительных данных
    Text sender; // адрес отправителя
    OpenFileRefArray of_arr; // of
    Nat of_arr_len;
}
is
**sk_buff** - данные внутри каждого буффера. Для *SOCK_DGRAM* и *SOCK_SEQPACKET*, можно сказать, предстваляет получаемую датаграмму. Для *SOCK_STREAM* буфферы будут читаться последовательно, отмечая уже прочитанные данные, учёт которых происходит в *consumed*. При *consumed* == *len* буффер считается полностью прочитанным и удаляется из очереди. 
endtype

type SocketStatus:
enum
    UNCONNECTED
    CONNECTING
    CONNECTED
    LISTEN
    LISTENING
    TCP_CLOSED 
is
**SocketStatus** - перечисление, в которых может находится сокет. 
endtype

type SocketFlag: 
enum
       SO_ACCEPTCONN
       SO_ATTACH_FILTER //(since Linux 2.2)
       SO_ATTACH_BPF //(since Linux 3.19)
       SO_ATTACH_REUSEPORT_CBPF
       SO_ATTACH_REUSEPORT_EBPF
       SO_BINDTODEVICE
       SO_BROADCAST
       SO_BSDCOMPAT // Уже не поддерживается
       SO_DEBUG
       SO_DETACH_FILTER //(since Linux 2.2)
       SO_DETACH_BPF //(since Linux 3.19)
       SO_DOMAIN
       SO_ERROR
       SO_DONTROUTE
       SO_INCOMING_CPU //(gettable since Linux 3.19, settable since Linux 4.4)
       SO_KEEPALIVE
       SO_LINGER
       SO_LOCK_FILTER
       SO_MARK //(since Linux 2.6.25)
       SO_OOBINLINE
       SO_PASSCRED
       SO_PASSSEC 
       SO_PEEK_OFF //(since Linux 3.4)
       SO_PEERCRED
       SO_PRIORITY
       SO_PROTOCOL //(since Linux 2.6.32)
       SO_RCVBUF // Does not have effect in unix socket (buf callable?)
       SO_RCVBUFFORCE //(since Linux 2.6.14)
       SO_RCVLOWAT
       SO_SNDLOWAT
       SO_RCVTIMEO
       SO_SNDTIMEO
       SO_REUSEADDR
       SO_REUSEPORT// (since Linux 3.9)
       SO_RXQ_OVFL //(since Linux 2.6.33)
       SO_SNDBUF
       SO_SNDBUFFORCE// (since Linux 2.6.14)
       SO_TIMESTAMP
       SO_TIMESTAMPNS
       SO_TIMESTAMPING
       SO_TYPE
       SO_BUSY_POLL //(since Linux 3.11)
is
**SocketFlag** - перечесление флагов сокета.    
end

type SocketFlags : SocketFlag-set

type SockType: # Чтобы закинуть, к примеру SOCK_NONBLOCK и SOCK_STREAM в один set. Пусть будет один тип.
enum
    SOCK_STREAM
    SOCK_DGRAM
    SOCK_SEQPACKET
    SOCK_RAW
    SOCK_RDM
    SOCK_PACKET
    SOCK_NONBLOCK
    SOCK_CLOEXEC
is
**SockType** - перечисление типов сокетов.
endtype

type ShutdownFlags:
enum
    RCV_SHUTDOWN   // Сокет не может читать 
    SEND_SHUTDOWN  // Сокет не может писать
endtype

type AddressFamily:
enum
    AF_UNIX // == AF_LOCAL
    AF_UNSPEC
is 
**AddressFamily** - перечесление семейств адрессов. В данной модели рассматривается только *AF_UNIX*. 
 
$enumdefs$
endtype

type sa_family_t = AddressFamily


type Protocol:
enum
    PF_UNIX // == PF_LOCAL
    PF_UNSPEC
is
**Protocol** - протоколы:

$enumdefs$
endtype

type Error: 
enum
    ENOTCONN
    ECONNABORTED
    EACCES
    EAFNOSUPPORT
    EINVAL
    EMFILE
    ENFILE
    ENOBUFS
    ENOMEM
    EPROTONOSUPPORT
    EBADF
    ENOTSOCK
    EINVAL
    EROFS
    EFAULT
    ENAMETOOLONG
    ENOENT
    ENOMEM
    ENOTDIR
    EACCES
    ELOOP
    ESOCKTNOSUPPORT
    EADDRINUSE
    EADDRNOTAVAIL
    EOPNOTSUPP
    EINTR
    EIO
    ENOSPC
    EDQUOT
    EPERM
    EAGAIN
    EALREADY
    ECONNREFUSED
    EINPROGRESS
    EISCONN
    ENETUNREACH
    EPROTOTYPE
    ETIMEDOUT
    EAGAIN
    ECONNABORTED
    EPROTO
    ECONNRESET
    EPIPE
    ESRCH
    EDESTADDRREQ
    EMSGSIZE
is
**Error** - перечисление всех кодов ошибок, которые могут возникать в событиях.
endtype

type sockaddr_un : struct
{
    AddressFamily sun_family;
    Text sun_path;
}
is
**sockaddr_un** - соотвествующая си структура, которая передаётся, например, в *bind*.
endtype

type ShutdownParam:
enum
    SHUT_RD
    SHUT_WR
    SHUT_RDWR
is
**ShutdownParam** - перечисление возможных значений параметра *how* в систменов вызове *shutdown*
endtype


type Level:
enum
    SOL_SOCKET
is
**SOL_SOCKET** - опции для всех сокетов или опции только юниксовых соектов
end

type MsgFlag:
enum
    MSG_CMSG_CLOEXEC # recvmsg only
    MSG_CONFIRM # implemented only ip => unix socket does not support this flag
    MSG_DONTROUTE # Похоже значение просто игнорируется
    MSG_DONTWAIT # OK
    MSG_EOR # Документация врёт. Он не возвращается в recv
    MSG_TRUNC # ok
    MSG_CTRUNC # OK
    MSG_PEEK
    MSG_MORE # Unix socket does not support this flag 
    MSG_NOSIGNAL # Don't generate a SIGPIPE signal if the peer on a stream-oriented socket  has closed the connection.  The EPIPE error is still returned.  This provides similar behavior to using sigaction(2) to ignore SIGPIPE, but, whereas MSG_NOSIGNAL is a per-call feature, ignoring SIGPIPE sets  a  process  attribute  that  affects  all threads in the process
    #/* On Linux, we must transmit at least 1 byte of real data in order to send ancillary data */
    MSG_OOB # Unix socket does not support this flag -> EINVAL как я понимаю
    
is
*MsgFlgas* - тип всех флагов для функций sendto, recvfrom
endtype

type CmsgType:
enum
    SCM_RIGHTS // SCM_RIGHTS 
    SCM_CREDENTIALS // SCM_CREDENTIALS  
    SCM_SECURITY // SCM_SECURITY 
is
*cmsg_type* - тип дополнительных данных в msghdr.  
$enumdefs$
end




type cmsghdr : struct {
    Nat cmsg_len;
    Level cmsg_level;
    CmsgType cmsg_type;
    Char* cmsg_data; // char cmsg_data[]
}
is
*cmsghdr* - структура данных, для загрузки дополнительных данных в msghdr.
end

#TODO: The maximum ancillary buffer size allowed per socket can be set using /proc/sys/net/core/optmem_max


type MsgFlags : MsgFlag-set

type iovec : struct {
    void* iov_base;
    Nat iov_len;
}
is
**iovec** - iovec для msghndr
endtype

type ioveclist : iovec-list

type msghdr : struct {
    Text      msg_name;
    Nat       msg_namelen;
    ioveclist msg_iov;
    Nat       msg_iovlen;
    void*     msg_control;
    Nat       msg_controllen;
    MsgFlags  msg_flags;
}
is
**msghdr** - структура для sendmsg/recvmsg
endtype



type RequstedAccessType:
enum
    READ
    WRITE
    EXEC
endtype

#TypesEnd

object OS is 
**OS** - объект, представляющий систему целиком
end

objattr os_open_file_table : OpenFile-set is
**os_open_file_table** - таблица открытых файлов ОС. В этой таблице происходит регистрация всех открытых в системе файлов.
end

objattr os_files : File-list is
**os_files** - множество всех файлов в файловой системе.
end

objattr os_proceses : Process-set is 
**Proos_procesescesses** - множество процессов в системе.
end

objattr os_socket_table : Text -m-> Socket is
**os_socket_table** - отображение адресса unix сокета (т.е. строки) в сокет с таким адресом.
end

objattr os_users : Uid-set is
**os_users** - множество всех пользователей, зарегистрированных в системе. (/etc/passwd)
end

objattr os_groups : Gid-set is
**os_groups** - множество всех пользователей, зарегистрированных в системе. (/etc/group)
end
endobject



object Process is
**Process** - отдельный процесс ОС.
end

objattr proc_pid : Int is
**proc_pid** - уникальный идентификатор процесса.
end

objattr proc_errno : Int is
**proc_errno** - атрибут, хранящий целочисленный код последней ошибки.
end

objattr proc_fds : Nat -m-> Fd is 
**proc_fds** - таблица открытых файловых дескрипторов процесса.
end

objattr proc_cred : Cred is
**proc_cred** - информация о правах процесса.
end

objattr proc_sigaction_array : Nat -m-> Sigaction is
**proc_sigaction_array** - информация об обработчиках сигналов процесса.
Отображение номера сигнала в стрктуру с информацией об обрабатывании этого
сигнала.
end

objattr proc_pending_signals : Nat-list is
**proc_pending_signals** - номера сигналов, пришедших на обработку. 
end

objattr proc_blocked_signals : Sigset is
**proc_blocked_signals** - в этом множестве находятся номера заблокированных для обработки сигналов.
end

objattr proc_status : ProcStatus is 
**proc_status** - текущее состояние процесса
end

objattr proc_cur_path : Text is
**proc_cur_path** - текущая рабочая директория процесса
end
endobject



object Fd is
**Fd** - файловый дескриптор.
end

objattr fd_open_file_ref : OpenFile* is 
**fd_open_file_ref** - ссылка на структуру с информацией об открытом файле.
end

objattr fd_flags : FdFlag-set is # Хотя возможен только один
**fd_flags** - флаги, которые приписаны к файловому дескриптору на уровне конкретного процесса.
end
endobject

object File is
**File** - объект, представляющий файл в ФС
end

objattr file_path : Text is
**file_path** - абсолютный путь до файла.
end

objattr file_type : FileType is
**file_type** - тип файла.
end

objattr file_cred : Fcred is
**file_cred** - Информация об обладателе и правах доступа
end
endobject



object OpenFile is 
**OpenFile** хранит информацию об открытом файле. Например, такие данные, как флаги доступа, оступ в файле и т.д..
end

# Бывший of_op_type - операции определённые для этого типа. Этим хотелось выразить наличия поля op в стркутуре откртытого файла, с целью различения типов открытых файлов. Здесь он просто равен типу файлу.
objattr of_type : FileType is
**of_type** - тип открытого файла. # Дублирует тип File. Дублирование необходимо т.к. файла для сокета в ФС ещё может не быть, но подсмотреть тип файла для описание ошибочных ситуаций нужно.  
end

objattr of_file : File* is
**of_file** - хранит ссылку на соотвестующий этому **OpenFile**, объект **File**.
end

objattr of_ref_cnt : Int is
**of_ref_cnt** - число ссылающихся на эту запись файловых дескрипторов.
end

objattr of_flags : OpenFileFlag-set is # Как-то не точно описано, но усложнять не хочется. (не точность в возможности присутствия одновременно O_RDONLY, и O_WRONLY, и O_RDWR, хотя в реальности возможно наличие только одного из них)  
**of_flags** - флаги открытого файла. 
end

objattr of_private_data : Socket* is
**of_private_data** - ссылка на важные структура данных. (Здесь находится ссылка на структуру сокет).
end
endobject



object Socket is 
**Socket** - объект представляющий собой UNIX сокет.
end

objattr socket_status : SocketStatus is
**socket_status** - текущий статус сокета
end

objattr socket_name : Text is
**socket_name** - значение в поле структуры sockaddr_un
end

objattr socket_address : Text is
**socket_address** - адрес сокета.
end

objattr socket_addrlen : Nat is
**socket_addrlen** - длина адреса сокета.
end

objattr socket_queue : Socket-list is 
**socket_queue** - очередь для accept.
end

objattr socket_backlog : Int is
**socket_backlog** - длина очереди полностью настроенных сокетов, которые ждут принятия.
end

objattr socket_peer : Socket-ref is
**socket_peer** - ссылка на сокета-друга, с котором происходит общение.
end

objattr socket_flags : SocketFlags is
**socket_flags** - флаги сокета. Осуществлять управление этими флагами можно с помощью *setsockopt* и  *getsockopt*
end

objattr socket_type : SockType is
**socket_type** - тип сокета.
end

objattr socket_shutdown_flags : ShutdownFlags-set is
**socket_shutdown_flags** - флаги, обозначающие закрытие на операции чтения и записи, выполняемые этим сокетом. 
end

objattr socket_buf : sk_buff-list is
**socket_buf_list** - буффер сокета.
end

objattr socket_so_sndbuf : Nat is
**socket_so_buff** - размер буффера сокета. Значение, получаемое getsockopt() с SO_SNDBUF
end

objattr socket_used_buffer : Nat is
**socket_used_buffer** - уже использованный количество байт буффера.
end

objattr socket_cur_buffer_cnt : Nat is
**socket_cur_buffer_cnt** - количество уже выделенных буфферов.
end
endobject



const DEFAULT_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_default
const MAX_SO_SNDBUF : Nat // Значение в /proc/sys/net/core/wmem_max


logical to_sockaddr_ref
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : sockaddr_un-ref
function
    * Преобразует указатель в sockaddr_un-ref
end


logical get_address
params
    T @TYPE
    prm1 @IN  : T
    ret  @OUT : T*
function
    * Взять адрес элемента
end



logical to_nat_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Nat*
function
    * Преобразует указатель в Nat*
end



logical to_int_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Int*
function
    * Преобразует указатель в Int*
end


logical to_char_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Char*
function
    * Преобразует указатель в char*
end



logical to_void_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : void*
function
    * Преобразует указатель в char*
end




logical to_ucred_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : Ucred*
function
    * Преобразует указатель в Ucred*
end


logical to_cmsghdr_pointer
params
    T    @TYPE
    prm1 @IN  : T*
    ret  @OUT : cmsghdr*
function
    * Преобразует указатель в указатель на cmsghdr
end



action add_to_list // Добавить элемент в список l (по стратегии fifo).
params
    T @TYPE
    l @IN : T-list
    el   @IN : T
function 
    l(\len l) := el
end


# TODO: action : взятия, удаления, возвращения
logical get_list_head // Взять первый элемент списка l с удалением.
params
    T    @TYPE
    l    @IN  : T-list
    el   @OUT : T
function
    * Взять первый элемент списка l с удалением.
end



action del_from_list // Удалить элемент idx из списка l.
params
    T    @TYPE
    fifo @IN  : T-list
    idx  @IN  : Nat
function
    * Удалить элемент idx из списка l.
end



action add_to_set
params
  T     @TYPE
  set1  @IN    : T-set
  el    @IN    : T
function
  set1 := set1 ∪ {. el .} // !Добавить el в set1
end



action remove_from_set
params
  T    @TYPE
  set1 @IN   : T-set
  el   @IN   : T
function
  set1 := set1 \diff {. el .}
end 



# Для сокращения записи
logical get_sock_data // получить структуру данных для процесса current и сокета sockfd.
params
    current @IN  : Process
    sockfd  @IN  : Nat
    sock    @OUT : Socket
function
    return \deref(current.proc_fds(sockfd).fd_open_file_ref->of_private_data)
end
    attr text: 'сокет, соответствующий файловому дескриптору {sockfd}'


# Для сокращения
event get_by_address
params
    os        @IN  : OS
    sock_addr @IN  : Text
    sock      @OUT : Socket
function 
    return os.os_socket_table(sock_addr)
end
    attr algorithm: 'Алгоритм, выдающий структуру сокета по адрессу'



# Для сокращения записи
logical get_open_file // получить открытый файл для процесс current и сокета fd.
params
    current @IN  : Process
    fd      @IN  : Nat
    opefile @OUT : OpenFile
function
    return \deref(current.proc_fds(fd).fd_open_file_ref)
end    
    attr text: 'открытый файл, соответствующий файловому дескриптору {fd}'


action add_to_map
params
  T1    @TYPE
  T2    @TYPE
  map   @IN    : T1 -m-> T2
  key   @IN    : T1
  el    @IN    : T2
function
    map(key) := el // !Добавить el в map с ключом key
end



action remove_from_map
params
  T1  @TYPE
  T2  @TYPE
  map @IN : T1 -m-> T2
  key @IN : T1
function
    * Удалить элемент key из map
end


const NULL : void*
const Nothing // Константа для неинициализированных частей

event socket // socket
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fd        @OUT : Int
invariant domain == AF_UNIX # Модель только для UNIX сокетов
invariant current \isin os.os_proceses # Текущей процесс существует в рамках системы
function
    possible_errors = socket_errors(os, current, domain, sock_type, protocol)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    newFD = generate_fd(current)
    socket = 'mk_socket(.socket_status=UNCONNECTED, .socket_address=Nothing, .socket_addrlen=Nothing, .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(), socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
        
    if (SOCK_STREAM \isin sock_type) {
        socket.socket_type := SOCK_STREAM
    } elif (SOCK_SEQPACKET \isin sock_type) {
       socket.socket_type := SOCK_SEQPACKET
    } else { # SOCK_RAW, SOCK_DGRAM
       socket.socket_type := SOCK_DGRAM
    }
    
    openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket)'    
        
    if (SOCK_NONBLOCK \isin sock_type) {
        add_to_set(openfile.of_flags, O_NONBLOCK)
    }
    
    if (SOCK_CLOEXEC \isin sock_type) {
        newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. FD_CLOEXEC .})'
    } else {
        newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'
    }
    
    add_to_map(current.proc_fds, newFD, newFDObject)
    add_to_set(os.os_open_file_table, openfile)
        
    return newFD
end



const PATH_MAX : Nat // Maximum path size in system


logical get_abs_path
params
    current @IN  : Process
    path    @IN  : Text
    abs     @OUT : Text
function
    if (path(0) == "\0") {
        return path
    }
    
    * Если путь абсолютный, то избавляемся от ., .., символьных ссылок в пути. 
    * Если путь относительный, добавляем слева current_cur_path и избавляемся от ., .., символьных ссылок в пути 
    * man path_resolution
end



const AutoBindAlphabet : Char-set // character set [0-9a-f]



event bind // bind
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Int
function    
    possible_errors = bind_errors(os, current, sockfd, sockaddr, addrlen)    
    
    sock_address = get_abs_path(current, sockaddr->sun_path)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }
    
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    socket.socket_address := sockaddr->sun_path
    
    if (addrlen == sizeof('sa_family_t')) { # Autobind feature -- Linux feature
        forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && \len(newUnixAddress) == 6 && newUnixAddress(0) == '\0' && newUnixAddress(1) \isin AutoBindAlphabet && newUnixAddress(2) \isin AutoBindAlphabet && newUnixAddress(3) \isin AutoBindAlphabet && newUnixAddress(4) \isin AutoBindAlphabet && newUnixAddress(5) \isin AutoBindAlphabet) {
            socket.socket_address := sock_address
            socket.socket_addrlen := 6 # One byte \0 + 5 of autobind address The change to 5 bytes came in Linux 2.3.15.)
            add_to_map(os.os_socket_table, sock_address, socket) # зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
            
            return 0
        }
    } else {
        if (sock_address(0) != '\0') { # Обычный сокет. Абстрактному сокету это не нужно.
            newFile = 'mk_File(.file_path=sock_address, .file_type=SOCKET_TYPE, .file_cred = { fc_uid, .fc_gid, .fc_permissions = {. S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH.} \diff current.proc_cred.cr_umask })' // Создание нового файла
            add_to_list(os.os_files, newFile) // Добавление файла в ФС
            openfile.of_file := newFile // сокет связывается с созданным файлом
        }
        
        socket.socket_name := sockaddr->sun_path
        socket.socket_addrlen := addrlen
        add_to_map(os.os_socket_table, sock_address, socket) // зафиксировать созданный сокет в системе и его адрес, для последующего нахождения. В Linux это реализует с помощью хэшей
        
        return 0
    }
end





const SOMAXCONN : Nat // максимально возможный размер очереди запросов на подключение (значение в /proc/sys/net/core/somaxconn файле)


function listen is
/**
 * @param sockfd  IN файловый дескриптор.
 * @param backlog IN числовой параметр, определяющий максиманльную длину очереди запросов на подключение.
 * @return код ошибки.
 */
int listen(int sockfd, int backlog);
end



event listen // вызов функции listen
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Int
function
    possible_errors = listen_errors(os, current, sockfd, backlog)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error //! Установить атрибуту proc_errno текущего процесса значение error.
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (backlog > SOMAXCONN) {
        socket.socket_backlog := SOMAXCONN
    } else {
        socket.socket_backlog := backlog
    }
    
    socket.socket_status := LISTEN
        
    return 0
end
    attr summary-cfg: True
    attr algo-tree: True


logical is_free_space_in_backlog
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появилось место для постановки себя в очередь на подключение (\len(server.socket_queue) < server.socket_backlog)



logical was_accepted
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    socket     @IN  : Socket
    res        @OUT : Bool 
end
    attr event-desc: Запрос на подключение был принят сервером. (socket \notisin server.socket_queue).

event connect // systemcall connect
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int 
function
    socket = get_sock_data(current, sockfd)
    server = get_by_address(os, sockaddr->sun_path)
    
    possible_errors = connect_errors(os, current, sockfd, sockaddr, addrlen, server)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    #Комментарий из кода -> Фича Linux: If possible we block in connect(2) if the max backlog of the listen socket is been reached. This won't break old apps and it will avoid huge amount of socks hashed (this for unix_gc() performances reasons).

    if (socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) {
        socket.socket_status := CONNECTING
        
        current.proc_status := S
        
       
        wait INFWAIT {
            trigger (is_free_space_in_backlog(server)) { // текст для триггера 1
                current.proc_status := R
                add_to_list(server.socket_queue, socket) 
            }
            
            trigger (interrupt_logical(current, socket)) { // текст для триггера 2
                current.proc_errno := EINTR
                current.proc_status := R
                return -1
            }
        }
        
        current.proc_status := S
        
        wait INFWAIT {
            trigger (was_accepted(server, socket)) { // текст для триггера 1
                #socket.socket_status := CONNECTED -- устанавливает это сервер (в accept)
                #socket.socket_peer := -- устанавливает это сервер.
                del_from_list(server.socket_queue, 0)
                current.proc_status := R
            }
                
            trigger (interrupt_logical(current, socket)) { // текст для триггера 2
                # Описать подчищивание надо? я про верхний wait. TODO(??)
                current.proc_errno := EINTR
                current.proc_status := R
                return -1
            }
        }
    } else {
        socket.socket_peer := \ref(server)
        socket.socket_status := CONNECTED
    }
    
    return 0    
end



logical backlog_is_not_empty
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Появился запрос на подключение (server.socket_queue != <..>)


event accept4 // accept4
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    flags    @IN  : SockType-set
    ret      @OUT : Int
function
    possible_errors = accept_errors(os, current, sockfd, sockaddr, addrlen, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    socket.socket_status := LISTENING
    current.proc_status := S
    
    wait INFWAIT { 
        trigger (backlog_is_not_empty(socket)) { // текст для триггера 1. Есть кого принимать
            current.proc_status := R
            socket.socket_status := LISTEN
            peer = get_list_head(socket.socket_queue) // Тот, кто подсоединяется
            newFD = generate_fd(current) // Создаются fd, OpenFile, Socket. Причём все поля у новых OpenFile и Socket такие же, как и у этих же объектов соотвестующих sockfd. 
            forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && newUnixAddress(0) == '\0') {
                new_socket = 'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress, .socket_addrlen=\len(newUnixAddress), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=peer, .socket_flags={. .}, .socket_type=socket.socket_type, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=socket.socket_so_sndbuf, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
            
            
                peer.socket_peer := new_socket
                peer.socket_status := CONNECTED
                
                if (sockaddr != to_sockaddr_ref(NULL)) { //sockaddr != NULL
                    * strncmp(\ref(\deref(sockaddr).sun_path), \ref(newUnixAddress), min(\len(newUnixAddress, \deref(addrlen)))
                    \deref(addrlen) := \len(newUnixAddress)      
                }

                openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, of_flags={. O_RDWR .}, .of_private_data=socket)'    
                newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'
                
                if (SOCK_NONBLOCK \isin flags) {
                    add_to_set(openfile.of_flags, O_NONBLOCK)
                }
                
                if (SOCK_CLOEXEC \isin flags) {
                    add_to_set(newFDObject.fd_flags, FD_CLOEXEC)
                }

                add_to_map(current.proc_fds, newFD, newFDObject)
                add_to_set(os.os_open_file_table, openfile)
                add_to_map(os.os_socket_table, new_socket.socket_address, new_socket)
            
                return newFD   
            }
        }
            
        trigger (interrupt_logical(current, socket)) { // текст для триггера 2
            current.proc_errno := EINTR
            current.proc_status := R
            socket.socket_status := LISTEN
            
            return -1   
        }
    }
end



#On Linux, the new socket returned by accept() does not inherit file status flags such as O_NONBLOCK and O_ASYNC from the listening socket. В POSIX об этом ничего нет.
event accept // accept
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Int
function
    possible_errors = accept_errors(os, current, sockfd, sockaddr, addrlen, \emptyset)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    socket.socket_status := LISTENING
    current.proc_status := S
    
    wait INFWAIT { 
        trigger (backlog_is_not_empty(socket)) { // текст для триггера 1. Есть кого принимать
            current.proc_status := R
            socket.socket_status := LISTEN
            peer = get_list_head(socket.socket_queue) // Тот, кто подсоединяется\
            newFD = generate_fd(current) // Создаются fd, OpenFile, Socket. Причём все поля у новых OpenFile и Socket такие же, как и у этих же объектов соотвестующих sockfd. 
                forany(newUnixAddress : Text | newUnixAddress \notisin \dom(os.os_socket_table) && newUnixAddress(0) == '\0') {
                    new_socket = 'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress, .socket_addrlen=\len(newUnixAddress), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=peer, .socket_flags={. .}, .socket_type=socket.socket_type, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=socket.socket_so_sndbuf, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
                
                    peer.socket_peer := new_socket
                    peer.socket_status := CONNECTED
                    
                    if (sockaddr != to_sockaddr_ref(NULL)) { //sockaddr != NULL
                        * strncmp(\ref(\deref(sockaddr).sun_path), \ref(newUnixAddress), min(\len(newUnixAddress, \deref(addrlen)))
                        \deref(addrlen) := \len(newUnixAddress)      
                    }

                    openfile = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, of_flags={. O_RDWR .}, .of_private_data=socket)'    
                    newFDObject = 'mk_Fd(.fd_open_file_ref=\ref(openfile), .fd_flags={. .})'

                    add_to_map(current.proc_fds, newFD, newFDObject)
                    add_to_set(os.os_open_file_table, openfile)
                    add_to_map(os.os_socket_table, new_socket.socket_address, new_socket)
                
                    return newFD   
                }
             
        }
            
        trigger (interrupt_logical(current, socket)) { // текст для триггера 2
            current.proc_errno := EINTR
            current.proc_status := R
            socket.socket_status := LISTEN
            
            return -1   
        }
    }
end



event close // close (описывался к применнию только для fd сокета)
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Int
invariant current.proc_fds(fd).fd_open_file_ref.of_ref_cnt >= 1// Если у файла ref_cnt == 0, то его в этой таблице быть не должно 
invariant current.proc_fds(fd).fd_open_file_ref.of_type == SOCKET_TYPE// Вызов рассматривается только для сокетов
function
    possible_errors = close_errors(os, current, fd)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, fd)
    open_file = get_open_file(current, fd)

    remove_from_map(current.proc_fds, fd)
    open_file.of_ref_cnt--
 
    if (open_file.of_ref_cnt == 0) {
        socket.socket_peer.socket_status := TCP_CLOSED
        remove_from_set(os.os_open_file_table, open_file)
        remove_from_map(os.os_socket_table, socket.socket_address)
    }
    
    return 0
end



event shutdown // shutdown
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Int
function
    possible_errors = shutdown_errors(os, current, sockfd, how)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)
    peer = socket.socket_peer

    if (how == SHUT_RD) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)  
    } elif (how == SHUT_WR) {
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    } elif (how == SHUT_RDWR) {
        add_to_set(peer.socket_shutdown_flags, SEND_SHUTDOWN)
        add_to_set(peer.socket_shutdown_flags, RCV_SHUTDOWN)
    }
    
    return 0    
end



event socketpair // socketpair
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fds       @IN  : Nat -m-> Nat
    fd        @OUT : Int
function
    possible_errors = socketpair_errors(os, current, domain, sock_type, protocol, fds)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }
    
    forany(newUnixAddress1 : Text | newUnixAddress1 \notisin \dom(os.os_socket_table) && newUnixAddress1(0) == '\0') {
        forany(newUnixAddress2 : Text | newUnixAddress2 \notisin \dom(os.os_socket_table) && newUnixAddress2(0) == '\0') {
            if (SOCK_CLOEXEC \isin sock_type) {
                newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. FD_CLOEXEC .})'
                newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. FD_CLOEXEC .})'
            } else {
                newFDObject1 = 'mk_Fd(.fd_open_file_ref=\ref(openfile1), .fd_flags={. .})'
                newFDObject2 = 'mk_Fd(.fd_open_file_ref=\ref(openfile2), .fd_flags={. .})'
            }
            
            newFD1 = generate_fd(current)
            add_to_map(current.proc_fds, newFD1, newFDObject1)
            newFD2 = generate_fd(current)
            add_to_map(current.proc_fds, newFD2, newFDObject2)
        
            socket1 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress1, .socket_addrlen=\len(newUnixAddress1), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
            socket2 =  'mk_socket(.socket_status=CONNECTED, .socket_address=newUnixAddress2, .socket_addrlen=\len(newUnixAddress2), .socket_queue=mk_empty_list(), .socket_backlog=Nothing, .socket_peer=Nothing, .socket_flags={. .}, .socket_type=Nothing, .socket_shutdown_flags={. .}, .socket_buf=mk_empty_list(),  socket_so_sndbuf=DEFAULT_SO_SNDBUF, .socket_used_buffer=0, .socket_cur_buffer_cnt=0)'
            socket1.socket_peer := socket2
            socket2.socket_peer := socket1
            
            
            
            if (SOCK_STREAM \isin sock_type) {
                socket1.socket_type := SOCK_STREAM
                socket2.socket_type := SOCK_STREAM
            } elif (SOCK_SEQPACKET \isin sock_type) { 
                socket1.socket_type := SOCK_SEQPACKET
                socket2.socket_type := SOCK_SEQPACKET
            } else { # SOCK_DGRAM, SOCK_RAW
                socket1.socket_type := SOCK_DGRAM
                socket2.socket_type := SOCK_DGRAM
            } 
            
            openfile1 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket1)'
            openfile2 = 'mk_OpenFile(.of_type=SOCKET_TYPE, .of_file=Nothing, .of_ref_cnt=1, ,of_flags={. O_RDWR .}, .of_private_data=socket2)'    
                
            if (SOCK_NONBLOCK \isin sock_type) {
                add_to_set(openfile1.of_flags, O_NONBLOCK)
                add_to_set(openfile2.of_flags, O_NONBLOCK)
            }
            
            add_to_set(os.os_open_file_table, openfile1)
            add_to_set(os.os_open_file_table, openfile2)
            add_to_map(os.os_socket_table, newUnixAddress1, socket1)
            add_to_map(os.os_socket_table, newUnixAddress2, socket2)

            fds(0) := newFD1
            fds(1) := newFD2
            
            return 0
        }
    }
end

############## IO part start ###########

#TODO
event getsockopt
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    level   @IN  : Level
    optname @IN  : SocketFlag
    optval  @IN  : void*
    optlen  @IN  : Nat*
    ret     @OUT : Int
function
    if (optname == SO_ACCEPTCONN) {
    } elif (optname == SO_ATTACH_FILTER) {
    } elif (optname == SO_ATTACH_BPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
    } elif (optname == SO_BINDTODEVICE) {
    } elif (optname == SO_BROADCAST) {
    } elif (optname == SO_BSDCOMPAT) {
    } elif (optname == SO_DEBUG) {
    } elif (optname == SO_DETACH_FILTER) {
    } elif (optname == SO_DETACH_BPF) {
    } elif (optname == SO_DOMAIN) {
    } elif (optname == SO_ERROR) {
    } elif (optname == SO_DONTROUTE) {
    } elif (optname == SO_INCOMING_CPU) {
    } elif (optname == SO_KEEPALIVE) {
    } elif (optname == SO_LINGER) {
    } elif (optname == SO_LOCK_FILTER) {
    } elif (optname == SO_MARK) {
    } elif (optname == SO_OOBINLINE) {
    } elif (optname == SO_PASSCRED) {
    } elif (optname == SO_PASSSEC) {
    } elif (optname == SO_PEEK_OFF) {
    } elif (optname == SO_PEERCRED) {
    } elif (optname == SO_PRIORITY) {
    } elif (optname == SO_PROTOCOL) {
    } elif (optname == SO_RCVBUF) {
    } elif (optname == SO_RCVBUFFORCE) {
    } elif (optname == SO_RCVLOWAT) {
    } elif (optname == SO_SNDLOWAT) {
    } elif (optname == SO_RCVTIMEO) {
    } elif (optname == SO_SNDTIMEO) {
    } elif (optname == SO_REUSEADDR) {
    } elif (optname == SO_REUSEPORT) {
    } elif (optname == SO_RXQ_OVFL) {
    } elif (optname == SO_SNDBUF) {
    } elif (optname == SO_SNDBUFFORCE) {
    } elif (optname == SO_TIMESTAMP) {
    } elif (optname == SO_TIMESTAMPNS) {
    } elif (optname == SO_TYPE) {
    } elif (optname == SO_BUSY_POLL) {
    } elif (optname == SO_TIMESTAMPING) {
    }
    
    return 0
end


#TODO
event setsockopt
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    level   @IN  : Level
    optname @IN  : SocketFlag
    optval  @IN  : void*
    optlen  @IN  : Nat
    ret     @OUT : Int
function
    #if (optname == SO_ACCEPTCONN) - не settable
    if (optname == SO_ATTACH_FILTER) {
    } elif (optname == SO_ATTACH_BPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_CBPF) {
    } elif (optname == SO_ATTACH_REUSEPORT_EBPF) {
    } elif (optname == SO_BINDTODEVICE) {
    } elif (optname == SO_BROADCAST) {
    } elif (optname == SO_BSDCOMPAT) {
    } elif (optname == SO_DEBUG) {
    } elif (optname == SO_DETACH_FILTER) {
    } elif (optname == SO_DETACH_BPF) {
    } elif (optname == SO_DOMAIN) {
    } elif (optname == SO_ERROR) {
    } elif (optname == SO_DONTROUTE) {
    } elif (optname == SO_INCOMING_CPU) {
    } elif (optname == SO_KEEPALIVE) {
    } elif (optname == SO_LINGER) {
    } elif (optname == SO_LOCK_FILTER) {
    } elif (optname == SO_MARK) {
    } elif (optname == SO_OOBINLINE) {
    } elif (optname == SO_PASSCRED) {
    } elif (optname == SO_PASSSEC) {
    } elif (optname == SO_PEEK_OFF) {
    } elif (optname == SO_PEERCRED) {
    } elif (optname == SO_PRIORITY) {
    } elif (optname == SO_PROTOCOL) {
    } elif (optname == SO_RCVBUF) {
    } elif (optname == SO_RCVBUFFORCE) {
    } elif (optname == SO_RCVLOWAT) {
    } elif (optname == SO_SNDLOWAT) {
    } elif (optname == SO_RCVTIMEO) {
    } elif (optname == SO_SNDTIMEO) {
    } elif (optname == SO_REUSEADDR) {
    } elif (optname == SO_REUSEPORT) {
    } elif (optname == SO_RXQ_OVFL) {
    } elif (optname == SO_SNDBUF) {
    } elif (optname == SO_SNDBUFFORCE) {
    } elif (optname == SO_TIMESTAMP) {
    } elif (optname == SO_TIMESTAMPNS) {
    } elif (optname == SO_TYPE) {
    } elif (optname == SO_BUSY_POLL) {
    } elif (optname == SO_TIMESTAMPING) {
    }
    
    
    return 0
end



logical interrupt_logical
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    current    @IN  : Process 
    socket     @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Прерывание ожидания процесса, из-за прихода сигнала, который не блокируется маской (current.proc_pending_signals != <..> && exists x:Nat | (x \isin current.proc_pending_signals) && (x \notisin curren.proc_blocked_signals)). Если для пришедшего сигнала верно SA_RESTART \isin current.proc_sigaction_array(signum).signal_flags && SO_RCVTIMEO \notisin socket.socket_flags это эквиваленто перезапуску системного вызова т.е. в этом случае res == False, иначе res == True. 



logical max_msg_cnt # Я не знаю как это получить. Оно зависит от SO_SNDBUF текущего сокета => Параметр - сокет-отправитель
params
    sock @IN  : Socket
    ret  @OUT : Nat
function
    * максимальное число отправленных сообщений в очереди
    # Как-то связано с so_sndbuf. Как это посчитать не знаю
end



event get_msg_len
params
    msg @IN  : msghdr*
    res @OUT : Nat
function
    def _res : Nat := 0

    for (i in [0..msg.msg_iovlen]) {
        _res := _res + msg.msg_iov(i).iov_len
    }
    
    return _res
end
    attr algorithm: 'Алгоритм, считающий размер данных в msg'



event load_data
params
    current @IN  : Process
    msg     @IN  : msghdr*
    sender  @IN  : Socket
    reciver @IN  : Socket
function
    def buf : sk_buff := 'mk_skbuff(".buf_data = alloc_ptr(), .data_len = 0, .consumed = 0, buf_control_data = alloc_prt(), control_len = 0", .sender = sender.socket_name)' // Устанавливается адрес отправителя
    sender.socket_used_buffer := sender.socket_used_buffer + get_msg_len(msg) //(Отмечается изменение использованного пространства буффера данного сокета)
    sender.socket_cur_buffer_cnt++
    
    for (i in [0..msg.msg_iovlen]) {
        // Данные просматриваются последовательно и загружаются подряд
        memcpy(buf.buf_data + buf.data_len, msg.msg_iov(i).iov_base, msg.msg_iov(i).iov_len) // Описываю будто адрессная арифметика с void* работает 1 байт
        // Устанавливается общий размер данных (поле data_len)
        buf.data_len := buf.data_len + msg.msg_iov(i).iov_len
    }
    
    if (msg.msg_controllen != 0) {
        //Если есть дополнительные данные, они загружаются
        
        buf.of_arr_len := 0
        def cmsg : cmsghdr* := CMSG_FIRSTHDR(msghdr)        
        
        while (cmsg != to_cmsghdr_pointer(NULL)) {
            if (cmsg->cmsg_type == SCM_RIGHTS) {
                def fd_arr : Nat* := to_nat_pointer(cmsg->cmsg_data)
                def fds_cnt : Nat := (cmsg->cmsg_len - sizeof('cmsghdr')) / sizeof('Int') 
            
                for (j in [0..fds_cnt]) {
                    def cur_fd : Nat := \deref(fd_arr + j)
                    fd_open_file = get_open_file(current, cur_fd)
                    fd_open_file.of_ref_cnt++
                    add_to_list(buf.of_arr, fd_open_file)
                    buf.of_arr_len++
                }
            } 
            # SCM_CREDENTIALS -> nothing to do
            # SCM_SECURITY -> TODO
            
            cmsg := CMSG_NXTHDR(msg, cmsg)
        }
        
        memcpy(buf.buf_control_data, msg.msg_control, msg.msg_controllen) 
        // Устанавливается размер дополнительных данных  
        buf.control_len := msg.msg_controllen
    } else {
        // Если их нет, то буффер == null
        buf.buf_control_data := NULL
        //Устанавливается размер дополнительных данных
        buf.control_len := 0
    }
    
    add_to_list(reciver.socket_buf, buf)
end
    attr algorithm: 'Алгоритм загрузки данных'



logical is_possible_to_load_data
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    sender     @IN  : Socket
    reciver    @IN  : Socket
    res        @OUT : Bool
end
    attr event-desc: Ждём освобождение места в буффера отправителя. (sender.socket_cur_buffer_cnt < max_msg_cnt(sender) && get_msg_len(msg) <= socket.socket_so_sndbuf * 2 - socket.socket_used_buffer)


#TODO:
logical CMSG_FIRSTHDR
params
    msg @IN  : msghdr*
    ret @OUT : cmsghdr*
function
    * В принципе понятно. Потом можно их позаменять на непосредственную работу.
end


logical CMSG_NXTHDR
params
    msg  @IN  : msghdr*
    cmsg @IN  : cmsghdr*
    res  @OUT : cmsghdr*
function
    * См. CMSG_FIRSTHDR
end



const SCM_MAX_FD : Nat := 253 // SCM_MAX_FD 

type Ucred : struct 
{
    Nat pid;
    Uid uid;
    Gid gid;
}
endtype



#TODO formalize
logical verify_cmsgs
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Error-set
function
   def errors : Error-set := {. .}
   def cur_cmsg : cmsghdr* := CMSG_FIRSTHDR(msg)
    
   while (cur_cmsg != 'NULL') {
        if (cur_cmsg->cmsg_level != SOL_SOCKET) {
           add_to_set(errors, EINVAL)
        } 
        
        if (cur_cmsg->cmsg_type == SCM_RIGHTS) {
            def fds_cnt : Nat := (cur_cmsg->cmsg_len - sizeof('cmsghdr')) / sizeof('Int') 
        
            if (fds_cnt > SCM_MAX_FD) {
                add_to_set(errors, EINVAL)
            }
            
            fds_arr = to_int_pointer(cur_cmsg->cmsg_data)
            
            forany(i : Nat | i < fds_cnt && \deref(fds_arr + i) \notisin \dom(current.proc_fds)) {
                add_to_set(errors, EBADF)                
            }
        } elif (cur_cmsg->cmsg_type == SCM_CREDENTIALS) {
              ucred = to_ucred_pointer(cur_cmsg->cmsg_data)
              
              if ((forall proc : Process | proc.proc_pid != ucred->pid) || ucred->uid \notisin os.os_users || ucred->gid \notisin os.os_groups) {
                add_to_set(errors, EINVAL)
              }
            
              if (current.proc_cred.cr_euid != 0 && (ucred->pid != current.proc_pid || (ucred->uid != current.proc_cred.cr_uid && ucred->uid != current.proc_cred.cr_euid && ucred->uid != current.proc_cred.cr_suid) || (ucred->gid != current.proc_cred.cr_gid && ucred->gid != current.proc_cred.cr_egid && ucred->gid != current.proc_cred.cr_sgid))) {
                add_to_set(errors, EACCES) # из кода
              }
        } elif (cur_cmsg->cmsg_type == SCM_SECURITY) {
            #TODO
        } else {
            add_to_set(errors, EINVAL)
        }
        
        cur_cmsg := CMSG_NXTHDR(msghdr, cur_cmsg)
   }
    
   return errors
end



action sendmsg_generic // sendmsg_generic
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    # at least one ordinary data byte 

    socket = get_sock_data(current, sockfd)
    
    if (socket.socket_type == SOCK_DGRAM) {
        other = get_by_address(os, msg->msg_name)
    } else {
        other = socket.socket_peer
    }

    current.proc_status := S
    wait INFWAIT {
        trigger (is_possible_to_load_data(socket, other)) {//сообщение для тригерра 1
            current.proc_status := R
            load_data(current, msg, socket, other)
        }
            
        trigger (interrupt_logical(current, socket)) { // сообщение для триггера 2
            current.proc_status := R
            current.proc_errno := EINTR
            return -1   
        }
    }
    
    
    socket.socket_peer := other
    return 0
end


const SIGPIPE : Nat // SIGPIPE


#If a blocked call to one of the following interfaces is
#interrupted by a signal handler, then the call is automatically
#restarted after the signal handler returns if the SA_RESTART flag
#was used; otherwise the call fails with the error EINTR:

#read, write, Socket interfaces: accept(2), connect(2), recv(2), recvfrom(2),
#recvmmsg(2), recvmsg(2), send(2), sendto(2), and sendmsg(2),
#unless a timeout has been set on the socket (see below).

#The following interfaces are never restarted after being
#interrupted by a signal handler, regardless of the use of
#SA_RESTART; they always fail with the error EINTR when
#interrupted by a signal handler:

#* "Input" socket interfaces, when a timeout (SO_RCVTIMEO) has
#been set on the socket using setsockopt(2): accept(2), recv(2),
#recvfrom(2), recvmmsg(2) (also with a non-NULL timeout
#argument), and recvmsg(2).

#"Output" socket interfaces, when a timeout (SO_RCVTIMEO) has
#been set on the socket using setsockopt(2): connect(2),
#send(2), sendto(2), and sendmsg(2).
event sendmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    possible_errors = sendmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
        if (EPIPE \isin possible_errors && MSG_NOSIGNAL \notisin flags) {
            add_to_list(current.proc_pending_signals, SIGPIPE)
        }
    
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
            return -1
        }
    }

    sendmsg_generic(os, current, sockfd, msg, flags)
end

event sendto //sendto
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags
    dst      @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat
    ret      @OUT : Int    
function
    #sendto TODO если получатель не указан установить получаетля peer'ом

    msg = 'mk_msg(.msg_name = dst->address, .msg_name_len = addrlen, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = sendmsg_errors(os, current, sockfd, \ref(msg), flags)
    
    if (possible_errors != {. .}) {
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
            return -1
        }
    }
    
    sendmsg_generic(os, current, sockfd, \ref(msg), flags)
end



event send // send
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    socket123 = get_sock_data(current, sockfd) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = sendmsg_errors(os, current, sockfd, \ref(msg), flags)
    
    if (possible_errors != {. .}) {
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
            return -1
        }
    }
    
    sendmsg_generic(os, current, sockfd, \ref(msg), flags)
end



event write // write
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void* # void *buf
    count   @IN  : Nat
    ret     @OUT : Int
function
    socket123 = get_sock_data(current, sockfd) # Там потом имя с socket из sendmsg_generic накладывается
    
    msg = 'mk_msg(msg_name = socket123.socket_peer.socket_address, msg_name_len = socket123.socket_peer.socket_address_len, ioveclist = &{buf, count}, msg_control = 0, msg_controllen = 0, msg_flags = 0)'
    
    possible_errors = sendmsg_errors(os, current, sockfd, \ref(msg), \emptyset)
    
    if (possible_errors != {. .}) {
        forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
            return -1
        }
    }
    
    sendmsg_generic(os, current, sockfd, \ref(msg), \emptyset)
end

#seqpacket в io ~ dgram
event min
params
    lhs @IN  : Int
    rhs @IN  : Int
    res @OUT : Int
function
    if (lhs < rhs) {
        return lhs
    } else {
        return rhs
    }
end
    attr algorithm: 'Алгоритм получения минимального среди двух Int.'
    
    
event max
params
    lhs @IN  : Int
    rhs @IN  : Int
    res @OUT : Int
function
    if (lhs > rhs) {
        return lhs
    } else {
        return rhs
    }
end
    attr algorithm: 'Алгоритм получения максимального среди двух Int.'


event memcpy
params
    T    @TYPE
    dest @IN   : T*
    src  @IN   : T*
    n    @IN   : Nat
function
    * Скопировать n байт из адреса src в адрес dest.
end
    attr algorithm: 'Алгоритм реализующий функцию memcpy из библиотеки СИ, но без возвращаемого результата'


logical generate_fd
params
    current @IN  : Process
    fd      @OUT : Nat
function
    forany(newFD : Nat | newFD \notisin \dom(current.proc_fds) && forall nn : Nat | (nn < newFD) => nn \isin \dom(current.proc_fds)) {
        return newFD
    }
end



event get_cmsg_data
params
    os      @IN  : OS
    current @IN  : Process
    reciver @IN  : Socket
    msg     @IN  : msghdr*
    flags   @IN  : MsgFlags
    buf     @IN  : sk_buff  
function
    //Если есть дополнительные данные, они загружаются
    def cmsg : cmsghdr* := to_cmsghdr_pointer(buf.buf_control_data)
    def cmsg_copied : Nat := 0

    while (cmsg != to_cmsghdr_pointer(NULL)) {
        if (cmsg->cmsg_type == SCM_RIGHTS) {
            going_to_copy = min(cmsg->cmsg_len, msg->msg_controllen - cmsg_copied)                   
            data_bytes = max(going_to_copy - sizeof('cmsghdr'), 0)
            fds_to_pass = data_bytes / sizeof('Int')
            
            if (fds_to_pass != \len(buf.of_arr)) {
                add_to_set(msg->msg_flags, MSG_CTRUNC)
            }
            
            if (fds_to_pass > 0) {
                memcpy(to_void_pointer(msg->msg_control) + cmsg_copied, to_void_pointer(cmsg->cmsg_data), sizeof('cmsghdr')) // copy header
                cmsg_copied := cmsg_copied + sizeof('cmsghdr')
                         
                for (k1 in [0..fds_to_pass]) {
                    def fd : Nat := generate_fd(current)
                    current.proc_fds(fd) := 'mk_Fd(.fd_open_file_ref=buf.of_arr(k1), .fd_flags={. .})'
                    buf.of_arr(k1).of_ref_cnt++
                    if (MSG_CMSG_CLOEXEC \isin flags) {
                        current.proc_fds(fd).fd_flags := {. FD_CLOEXEC .}
                    }
                    
                    * memcpy(msg->cmsg_control + cmsg_copied, &fd, sizeof('Int'))
                    cmsg_copied := cmsg_copied + sizeof('Int')
                }
            }        
        } elif ('cmsg->cmsg_type == SCM_CREDENTIALS && SO_PASSCRED \isin reciver.socket_flags') {
            if (cmsg->cmsg_len > msg->msg_controllen - cmsg_copied) {
                add_to_set(msg->msg_flags, MSG_CTRUNC)
            } else {
                memcpy(to_void_pointer(to_char_pointer(msg->msg_control) + cmsg_copied), to_void_pointer(cmsg), cmsg->cmsg_len)
                cmsg_copied := cmsg_copied + cmsg->cmsg_len
            }            
        } elif ('cmsg->cmsg_type == SCM_SECURITY && SO_PASSSEC \isin reciver.socket_flags') {
            if (cmsg->cmsg_len > msg->msg_controllen - cmsg_copied) {
                add_to_set(msg->msg_flags, MSG_CTRUNC)
            } else {
                memcpy(to_void_pointer(to_char_pointer(msg->msg_control) + cmsg_copied), to_void_pointer(cmsg), cmsg->cmsg_len)
                cmsg_copied := cmsg_copied + cmsg->cmsg_len
            }  
        }
        
        cmsg := CMSG_NXTHDR(msg, cmsg)
    }
    
    msg->msg_controllen := cmsg_copied // Устанавливается размер дополнительных данных
end
    attr algorithm: 'Алгоритм получения контрольных данных.'



event get_data
params
    os      @IN  : OS
    current @IN  : Process
    reciver @IN  : Socket
    msg     @IN  : msghdr*
    flags   @IN  : MsgFlags
    ret     @OUT : Nat
function
    def copied : Nat := 0
    def i : Nat := 0
    def iov : iovec # снести в alias

    if (reciver.socket_type == SOCK_DGRAM || reciver.socket_type == SOCK_SEQPACKET) {       
        buf = reciver.socket_buf(0) // Первая пришедшая датаграмма
        sender = get_by_address(os, buf.sender) // Отправитель

        while ('i < msg->msg_iovlen && buf.consumed < buf.data_len') { #TODO while с двумя условиями
            iov := msg->msg_iov(i)
            cur_dgram_copied = min(iov.iov_len, buf.data_len - buf.consumed)
            
            memcpy(iov.iov_base, buf.buf_data + buf.consumed, cur_dgram_copied)
            copied := copied + cur_dgram_copied
            buf.consumed := buf.consumed + cur_dgram_copied
            
            if (cur_dgram_copied == iov.iov_len) {
                i++
            }
        }  
        
        if (buf.control_len != 0) {
            get_cmsg_data(os, current, reciver, msg, flags, buf)
        } else {
            // Если их нет, то буффер == null
            msg->msg_control := NULL
            //Устанавливается размер дополнительных данных
            msg->msg_controllen := 0
        }
                
        if (buf.consumed != buf.data_len) {
            add_to_set(msg->msg_flags, MSG_TRUNC)
        }
        
        if (MSG_PEEK \notisin flags) {
            sender.socket_used_buffer := sender.socket_used_buffer - buf.data_len // Освобождается память в буффере отправителя для последующих сообщений.
            sender.socket_cur_buffer_cnt-- 
            del_from_list(reciver.socket_buf, 0) // Прочитанная датаграмма удаляется.
        } else {
            buf.consumed := buf.consumed - copied
        }
        
        if ('reciver.socket_type == SOCK_DGRAM && MSG_TRUNC \isin flags') {
            return buf.data_len // return real dgram size
        } else {
            return copied
        }
    } else {// recvier.socket_type == SOCK_STREAM
        def cur_iov_base_size : Nat := 0 # cur_len of current iov
        def cur_buf_to_read : Nat := 0
        
        while ('i < msg->msg_iovlen && cur_buf_to_read < \len(socket.socket_buf)') {
            buf = reciver.socket_buf(cur_buf_to_read)
            
            def cur_stream_copied : Nat := 0
            # copy one socket buff
            while ('i < msg->msg_iovlen && buf.consumed < buf.data_len') {
                iov := msg->msg_iov(i)
            
                bytes_to_copy = min(iov.iov_len - cur_iov_base_size, buf.data_len - buf.consumed)
                
                cur_stream_copied := cur_stream_copied + bytes_to_copy
                cur_iov_base_size := cur_iov_base_size + bytes_to_copy
                memcpy(iov.iov_base + cur_iov_base_size, buf.buf_data + buf.consumed, bytes_to_copy) // Предполагаю, что адресная арифметика для void* (т.е. iov.iov_base) байтова (void *) + 1 - сдвиг адреса на единицу
                buf.consumed := buf.consumed + bytes_to_copy
            
                if (cur_iov_base_size == iov.iov_len) {
                    cur_iov_base_size := 0
                    i++
                }
            }
            
            copied := copied + cur_stream_copied
            
            if ('buf.buf_control_data != NULL && buf.consumed == buf.data_len') { // Если есть дополнительные данные
                // Копируются дополнительный данные
                get_cmsg_data(os, current, reciver, msg, flags, buf)
                
                goto endRead
            } elif (buf.consumed == buf.data_len) {
                cur_buf_to_read++
            }
        }
        
endRead:       
        if (MSG_PEEK \notisin flags) {
            for (k in [0..cur_buf_to_read]) {
                buf = reciver.socket_buf(0)
            
                for (k1 in [0..\len(buf.of_arr)]) {
                    buf.of_arr(k1).of_ref_cnt--
                }
            
                other = get_by_address(os, buf.sender)
                other.socket_used_buffer := other.socket_used_buffer - buf.data_len
                other.socket_cur_buffer_cnt--
                del_from_list(socket_buf, 0)
            }
        }
        
        return copied     
   }
end
    attr algorithm: 'Алгоритм получения данных.'



logical msg_have_come
params
    pre_state  @IN  : Universe
    post_state @IN  : Universe
    server     @IN  : Socket
end
    attr event-desc: Появилось сообщения для считывания в буффере. (server.socket_buf != <. .>))



action recvmsg_generic
params
    os          @IN  : OS
    current     @IN  : Process
    sockfd      @IN  : Nat
    msg         @IN  : msghdr*
    flags       @IN  : MsgFlags
    paddrlen    @IN  : Nat*
function
    socket = get_sock_data(current, sockfd)
    
    current.proc_status := S
    wait INFWAIT {
        trigger (msg_have_come(socket)) { // Описание триггера 1
            current.proc_status := R
            
            if (msg->msg_name == 'NULL' && paddrlen == to_nat_pointer(NULL)) {
                res = get_data(os, current, socket, msg, flags)
                # msg_namelen ссылкается на поданный буффер, так что заполняя его, сразу заполняем ответ. 
                \deref(paddrlen) := msg.msg_namelen # с длинной адресса не так
            } else {
                res = get_data(os, current, socket, msg, flags)
            }
        
            
            return res
        }
        
        trigger (interrupt_logical(current, socket)) { // Описание триггера для прерываний
            current.proc_errno := EINTR
            current.proc_status := R
            return -1   
        }
    }
end





event recvmsg //recvmsg
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Int
function
    possible_errors = recvmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    recvmsg_generic(os, current, sockfd, msg, flags, \ref(msg->msg_namelen))
end


event recvfrom //recvfrom
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : Nat-set
    src      @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Int  
function
    msg = 'mk_msg(.msg_name = src->address, .msg_name_len = \deref(addrlen), .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = recvmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }
    
    recvmsg_generic(os, current, sockfd, msg, flags, addrlen)
end


event recv // recv
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    buf      @IN  : void*
    len      @IN  : Nat
    flags    @IN  : MsgFlags
    ret      @OUT : Int  
function
    socket123 = get_sock_data(current, sockfd)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = Nothing, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = recvmsg_errors(os, current, sockfd, msg, flags)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }
    
    recvmsg_generic(os, current, sockfd, msg, flags, to_nat_pointer(NULL))
end



event read // read
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    buf     @IN  : void*
    count   @IN  : Nat  
    ret     @OUT : Int
function
    socket123 = get_sock_data(current, sockfd)
    
    msg = 'mk_msg(.msg_name = socket123.socket_peer.socket_address, .msg_name_len = socket123.socket_peer.socket_address_len, .msg_iov = \ref({buf, len}), .msg_control = 0, .msg_controllen = 0, .msg_flags = {. .})'
    
    possible_errors = recvmsg_errors(os, current, sockfd, msg, \emptyset)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }
    
    recvmsg_generic(os, current, sockfd, msg, \emptyset, to_nat_pointer(NULL))
end




action truncate_address // Заполнить всю структуру нулями. 
params
    addr    @IN : sockaddr_un-ref
function
    * Заполнить всю структуру нулями.
end





event getpeername
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : sockaddr_un-ref
    addrlen @IN  : Nat*
    ret     @OUT : Int
function
    possible_errors = getpeername_errors(os, current, sockfd, address, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (\deref(addrlen) > socket.socket_addrlen) {
        address->sun_family := AF_UNIX
        address->sun_path := socket.socket_peer.socket_name
    } else { # Buffer is too small
        truncate_address(address) # Truncate address
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end



event getsockname
params
    os      @IN  : OS
    current @IN  : Process
    sockfd  @IN  : Nat
    address @IN  : sockaddr_un-ref
    addrlen @IN  : Nat*
    ret     @OUT : Int
function
    possible_errors = getsockname_errors(os, current, sockfd, address, addrlen)
    
    if (possible_errors != {. .}) {
          forany(error : Int | error \isin possible_errors) {
  	        current.proc_errno := error
           	return -1
          }
    }

    socket = get_sock_data(current, sockfd)

    if (\deref(addrlen) > socket_addrlen) {
        address->sun_family := AF_UNIX
        address->sun_path := socket.socket_name
    } else { // Buffer is too small
        truncate_address(address) 
    }
    
    \deref(addrlen) := socket_addrlen
    
    return 0
end



const POSSIBLE_SOCKET_TYPES : SockType-set-set // Множество корректных типов сокета {. SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET .} >< {. SOCK_NONBLOCK .} >< {. SOCK_CLOEXEC .}. Тип сокета (SOCK_STREAM, SOCK_DGRAM, SOCK_RDM etc), и (опционально) флаги SOCK_NONBLOCK или SOCK_CLOEXEC. Т.е. либо тройка, либо двойка, либо только тип сокета (SOCK_STREAM etc).
const MAX_FDS_PER_PROC : Nat // Максимальное число файловых дескрипторов для одного процесса
const MAX_OPEN_FILES   : Nat // Максимальное число открытых файлов в системе. Это число может быть найдено, например, в файле /proc/sys/fs/file-max



logical set_len
params
  T    @TYPE
  setP @IN : T-set
  res  @OUT: Nat
end
  attr text: Количество элементов в множестве {setP}



logical socket_errors // сокращение для получения множество вохможноых ошибок, при заданных входных данных для системного вызова socket.
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set // Почему-то SOCK_STREAM | SOCK_DGRAM в AF_UNIX успешно создает SOCK_DGRAM сокет...
    protocol  @IN  : Protocol
    errors    @OUT : Error-set
function

    return {. errcode for errcode : Error | (errcode == EACCES) && False || # EACCES не нашёл где возникает, кроме случая с андроид
    (errcode == EAFNOSUPPORT) && (domain != AF_UNIX) ||
    (errcode == EPROTONOSUPPORT) && (protocol != PF_UNIX && protocol != 0) || 
    (errcode == EINVAL) && (sock_type \notisin POSSIBLE_SOCKET_TYPES) || 
    (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
    (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
    (errcode == ENOBUFS) && False || # Не знаю как, поэтому не специфицирую
    (errcode == ENOMEM) && False ||  # Не знаю как, поэтому не специфицирую 
    (errcode == ESOCKTNOSUPPORT) && (sock_type \intersect {. SOCK_STREAM .} == {. .} || sock_type \intersect {. SOCK_DGRAM .} == {. .} && sock_type \intersect {. SOCK_SEQPACKET .} == {. .}) .}
end



logical bind_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un*
    addrlen  @IN  : Nat
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    abs_path = get_abs_path(current, sockaddr->sun_path)
    
    return {. errcode for errcode : Error | (errcode == EACCES) && (abs_path(0) != "\0" && !access_to_write(os, current, abs_path)) ||
        (errcode == EADDRINUSE) && (abs_path \isin \dom(os.os_socket_table)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINVAL) && (socket.socket_addrlen != 0 || (addrlen != sizeof('sockaddr_un') && addrlen != sizeof('sa_family_t'))) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EADDRNOTAVAIL) && (False) || 
        (errcode == EFAULT) && (False) ||
        (errcode == ELOOP) && (False) || # Todo
        (errcode == ENAMETOOLONG) && (addrlen >= PATH_MAX) || 
        (errcode == ENOENT) && (\len(get_files_in_path(os, abs_path)) == 0) || #Одной из директорий в пути для данного адреса не существует
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTDIR) && (!is_all_files_in_path_dirs(os, current, abs_path)) || 
        (errcode == EROFS) && (False) .}
end


logical listen_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    backlog  @IN  : Int
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)

    # У unix socket eaddrinuse не возникает
    return {. errcode for errcode : Error | (errcode == EADDRINUSE) && (socket.socket_address \isin \dom(os.os_socket_table)) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type == SOCK_DGRAM).}
end    
    attr text: 'множество ошибок, которые должны произойти при вызове функции listen с параметрами {sockfd}, {backlog}'



logical connect_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Int
    sockaddr @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat
    server   @IN  : Socket
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EACCES) && (socket.socket_address(0) != "\0" && !access_to_write(os, current,  socket.socket_address)) || 
        (errcode == EPERM) && (False) || 
        (errcode == EADDRINUSE) && (socket.socket_address \isin \dom(os.os_socket_table)) || 
        (errcode == EADDRNOTAVAIL) && (False) || 
        (errcode == EAFNOSUPPORT) && (sockaddr.sun_family != AF_UNIX) ||
        (errcode == EAGAIN) && (O_NONBLOCK \isin openfile.of_flags && \len(server.socket_queue) < server.socket_backlog) || 
        (errcode == EALREADY) && (False) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNREFUSED) && (server.socket_status != LISTEN) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EISCONN) && (socket.socket_status == CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EPROTOTYPE) && (socket.socket_type != server.socket_type) || 
        (errcode == ETIMEDOUT) && (False) .}
end


# TODO
#The receive queue is logically terminated if an end-of-file indication has been received or a connection has been terminated. A segment shall be considered to be terminated if another segment follows it in the queue, if the segment completes a record, or if an end-of-file or other connection termination has been reported. The last segment in the receive queue shall also be considered to be terminated while the socket has a pending error to be reported.


logical accept_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    sockaddr @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    flags    @IN  : SockType-set
    ret      @OUT : Error-set    
function
#If address is not a null pointer, the address of the peer for the accepted connection shall be stored in the sockaddr structure pointed to by address, and the length of #this address shall be stored in the object pointed to by address_len.

#If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address shall be truncated.
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EAGAIN) && (O_NONBLOCK \isin openfile.of_flags && socket.socket_queue == <..>) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNABORTED) && (False) || 
        (errcode == EFAULT) && (False) ||
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un') || socket.socket_status != LISTEN || RCV_SHUTDOWN \isin socket.socket_shutdown_flags) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES) ||
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == EOPNOTSUPP) && (socket.socket_type != SOCK_STREAM && socket.socket_type != SOCK_SEQPACKET) || 
        (errcode == EPROTO) && (False) .}
end



logical close_errors
params
    os       @IN  : OS
    current  @IN  : Process
    fd       @IN  : Nat
    ret      @OUT : Error-set
function    
    return {. errcode for errcode : Error | (errcode == EBADF) && (fd \notisin \dom(current.proc_fds)) || 
        (errcode == EINTR) && (False) || 
        (errcode == EIO) && (False) || 
        (errcode == ENOSPC) && (False) || 
        (errcode == EDQUOT) && (False).}
end



logical shutdown_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    how      @IN  : ShutdownParam
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EINVAL) && (how != SHUT_RD && how != SHUT_WR && how != SHUT_RDWR) || 
        (errcode == ENOTCONN) && (socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end



logical socketpair_errors
params
    os        @IN  : OS
    current   @IN  : Process
    domain    @IN  : AddressFamily
    sock_type @IN  : SockType-set
    protocol  @IN  : Protocol
    fds       @IN  : Nat -m-> Nat
    ret      @OUT : Error-set
function    
    return {. errcode for errcode : Error | (errcode == EAFNOSUPPORT) && (domain != AF_UNIX) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EMFILE) && (set_len(\dom(current.proc_fds)) == MAX_FDS_PER_PROC - 1) ||
        (errcode == ENFILE) && (set_len(os.os_open_file_table) == MAX_OPEN_FILES - 1) ||
        (errcode == EOPNOTSUPP) && (protocol != PF_UNIX && protocol != PF_UNSPEC) || 
        (errcode == EPROTONOSUPPORT) && (protocol != PF_UNIX && protocol != PF_UNSPEC) .}
end


logical getpeername_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    address  @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un')) || 
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOTCONN) && (socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end



logical getsockname_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    address  @IN  : sockaddr_un-ref
    addrlen  @IN  : Nat*
    ret      @OUT : Error-set
function
    openfile = get_open_file(current, sockfd)
    
    return {. errcode for errcode : Error | (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (\deref(addrlen) != sizeof('sockaddr_un')) || 
        (errcode == ENOBUFS) && (False) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) .}
end



logical recvmsg_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    if (msg->msg_namelen == 0) {
        sender_path = socket.socket_peer.socket_address
        sender = socket.socket_peer
    } else {
        sender_path = get_abs_path(current, msg->msg_name)
        sender = get_by_address(os, sender_path)
    }

    
    # ENOTSOCK last in recvmsg
    # нужно проверить что после wait всё открыто всё доступно
    return {. errcode for errcode : Error | (errcode == EAGAIN) && ((O_NONBLOCK \isin openfile.of_flags || MSG_DONTWAIT \isin flags) && socket.socket_buf == <. .>) || 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == ECONNREFUSED) && (socket.socket_addrlen == 0) || 
        (errcode == EFAULT) && (False) || 
        (errcode == EINVAL) && (MSG_OOB \isin MsgFlags) || 
        (errcode == ENOMEM) && (False) || 
        (errcode == ENOTCONN) && ((socket.socket_type == SOCK_STREAM || socket.socket_type == SOCK_SEQPACKET) && socket.socket_status != CONNECTED) || 
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) || 
        (errcode == ENOTCONN) && (msg->msg_namelen == 0 && socket.socket_status != CONNECTED) ||
        (errcode == EPROTOTYPE) && (socket.socket_type != sender.socket_type) .}
end



logical sendmsg_errors
params
    os       @IN  : OS
    current  @IN  : Process
    sockfd   @IN  : Nat
    msg      @IN  : msghdr*
    flags    @IN  : MsgFlags
    ret      @OUT : Error-set
function
    socket = get_sock_data(current, sockfd)
    openfile = get_open_file(current, sockfd)
    
    if (msg->msg_namelen == 0) {
        reciver_path = socket.socket_peer.socket_address
        reciver = socket.socket_peer
    } else {
        reciver_path = get_abs_path(current, msg->msg_name)
        reciver = get_by_address(os, reciver_path)
    }

    # EPIPE - последний в sendmsg
    res1 = {. errcode for errcode : Error | (errcode == EACCES) && (!access_to_write(os, current, reciver_path)) || 
        (errcode == EAGAIN) && ((O_NONBLOCK \isin openfile.of_flags || MSG_DONTWAIT \isin flags) && (socket.socket_cur_buffer_cnt == max_msg_cnt(socket) || get_msg_len(msg) > socket.socket_so_sndbuf * 2 - socket.socket_used_buffer)) || 
        (errcode == EALREADY) && (False) || # for internet socket only 
        (errcode == EBADF) && (sockfd \notisin \dom(current.proc_fds)) || 
        (errcode == EDESTADDRREQ) && ((msg->msg_namelen == 0 && socket.socket_status == CONNECTED) || (msg.msg_namelen != 0 && reciver_path \notisin \dom(os.os_socket_table))) || 
        (errcode == EFAULT) && (False) ||  
        (errcode == EINVAL) && (MSG_OOB \isin flags) ||  
        (errcode == EISCONN) && (msg.msg_namelen != 0 && socket.socket_type == SOCK_STREAM && socket.socket_status == CONNECTED) ||  
        (errcode == EMSGSIZE) && (get_msg_len(msg) > socket.socket_so_sndbuf) ||  
        (errcode == ENOBUFS) && (False) ||  
        (errcode == ENOMEM) && (False) ||  
        (errcode == ENOTSOCK) && (openfile.of_type != SOCKET_TYPE) ||  
        (errcode == EPIPE) && (SEND_SHUTDOWN \isin socket.socket_shutdown_flags || RCV_SHUTDOWN \isin reciver.socket_shutdown_flags) || 
        (errcode == ECONNRESET) && (socket.socket_peer.socket_address \notisin \dom(os.os_socket_table)) ||
        (errcode == ENOENT) && (\len(get_files_in_path(os, reciver_path)) == 0) ||
        (errcode == ENOTCONN) && (msg.msg_namelen == 0 && socket.socket_status != CONNECTED) ||
        (errcode == EPROTOTYPE) && (socket.socket_type != reciver.socket_type) .}
    
    res2 = verify_cmsgs(os, current, sockfd, msg, flags) # ESRCH, EPERM, EINVAL
    
    return res1 \union res2
end



event get_files_in_path
params
    os   @IN  : OS
    path @IN  : Text
    res  @OUT : File-list
function
    def res_list : File-list := <. .>
    
    for (i in [0..\len(path)]) {
        if (path(i) == "/") {
            def file_abs_path : Text := ""
            cur_file = os.os_files(i)
            
            for (k in [0..i]) {
                file_abs_path(k) := path(k)
            }
            
            def was_found : Bool := False
            def j : Nat := 0
            while ('j < \len(os.os_files) && !was_found') {
                
                if (cur_file.file_path == file_abs_path) {
                    was_found := True
                }
                
                j++
            }
            
            if (was_found) {
                add_to_list(res_list, cur_file)
            } else {
                res_list := <. .>
                return res_list
            }
        }
    }

    return res_list
end
    attr algorithm: 'Алгоритм выделения файлов в пути'



logical groupmember
params
    gid   @IN  : Gid
    cred  @IN  : Cred
    ret   @OUT : Bool
function
    if (gid == cred.cr_egid) {
        return True
    } else {
        forany(group : Gid | group \isin cred.cr_groups) {
            if (group == gid) {
                return True
            } else {
                return False
            }
        }
    }
end



logical access
params
    os          @IN  : OS
    current     @IN  : Process
    access_type @IN  : RequstedAccessType
    file        @IN  : File
    ret         @OUT : Bool
function
    cred = current.proc_cred
    fcred = file.file_cred
    ftype = file.file_type
    
    if (cred.cr_euid == 0) {
        return (access_type == EXEC && ftype != DIRECTORY_TYPE && (fcred.fc_permission \intersect {. S_IXUSR, S_IXGRP, S_IXOTH .} != {. .}))
    } else {       
        if (cred.cr_euid == fcred.fc_uid) {
            if (access_type == EXEC) {
                mask = {. S_IXUSR .}
            } elif (access_type == READ) {
                mask = {. S_IRUSR .}
            } else {
                mask = {. S_IWUSR .}
            }
        } elif (groupmember(fcred.fc_gid, cred)) {
            if (access_type == EXEC) {
                mask = {. S_IXGRP .}
            } elif (access_type == READ) {
                mask = {. S_IRGRP .}
            } else {
                mask = {. S_IWGRP .}
            }
        } else {
            if (access_type == EXEC) {
                mask = {. S_IXGRP .}
            } elif (access_type == READ) {
                mask = {. S_IRGRP .}
            } else {
                mask = {. S_IWGRP .}
            }
        }
        
        return (fcred.fc_permission \intersect mask) == mask
    }
end



logical is_all_files_in_path_dirs
params
    os      @IN  : OS
    current @IN  : Process
    path    @IN  : Text
    res     @OUT : Bool
function
    files = get_files_in_path(os, path)
    
    for (i in [0..\len(files) - 1]) {
        if (files(i).file_type != DIRECTORY_TYPE) {
            return False
        }
    }
    
    return True
end


logical access_to_write
params
    os      @IN  : OS
    current @IN  : Process
    path    @IN  : Text
    res     @OUT : Bool
function
    files = get_files_in_path(os, path)
    
    if (\len(files) == 0) {
        return True # это другая ошибка
    } else {
        for (i in [0..\len(files) - 1]) {
            if (access(os, current, EXEC, files(i))) {
                return False
            }
        }
        
        if (!access(os, current, WRITE, files(\len(files) - 1))) {
            return False
        }
    }
    
    return True
end



logical sizeof
  params
    T   @IN      @CTYPE
    res @OUT   : Int # size_t
end
  attr text: 'sizeof({T})'



note 'OBJTREE_NOTE' is
@objtree[root:OS]@
endnote

endmodule

